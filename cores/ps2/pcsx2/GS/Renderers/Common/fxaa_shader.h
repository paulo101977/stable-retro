/* FXAA shader */
const char fxaa_shader_raw[] =
"#if defined(SHADER_MODEL) || defined(FXAA_GLSL_130)\n"
"#ifndef FXAA_GLSL_130\n"
"    #define FXAA_GLSL_130 0\n"
"#endif\n"
"#define UHQ_FXAA 1          //High Quality Fast Approximate Anti Aliasing. Adapted for GS from Timothy Lottes FXAA 3.11.\n"
"#define FxaaSubpixMax 0.0   //[0.00 to 1.00] Amount of subpixel aliasing removal. 0.00: Edge only antialiasing (no blurring)\n"
"#define FxaaEarlyExit 1     //[0 or 1] Use Fxaa early exit pathing. When disabled, the entire scene is antialiased(FSAA). 0 is off, 1 is on.\n"
"#if (FXAA_GLSL_130 == 1)\n"
"in SHADER\n"
"{\n"
"    vec4 p;\n"
"    vec2 t;\n"
"    vec4 c;\n"
"} PSin;\n"
"layout(location = 0) out vec4 SV_Target0;\n"
"layout(std140, binding = 14) uniform cb14\n"
"{\n"
"    vec2 _xyFrame;\n"
"    vec4 _rcpFrame;\n"
"};\n"
"#elif (SHADER_MODEL >= 0x400)\n"
"Texture2D Texture : register(t0);\n"
"SamplerState TextureSampler : register(s0);\n"
"cbuffer cb0\n"
"{\n"
"	float4 _rcpFrame : register(c0);\n"
"};\n"
"struct VS_INPUT\n"
"{\n"
"	float4 p : POSITION;\n"
"	float2 t : TEXCOORD0;\n"
"};\n"
"\n"
"struct VS_OUTPUT\n"
"{\n"
"	float4 p : SV_Position;\n"
"	float2 t : TEXCOORD0;\n"
"};\n"
"\n"
"struct PS_OUTPUT\n"
"{\n"
"	float4 c : SV_Target0;\n"
"};\n"
"\n"
"#endif\n"
"\n"
"/*------------------------------------------------------------------------------\n"
"                             [FXAA CODE SECTION]\n"
"------------------------------------------------------------------------------*/\n"
"\n"
"#if (SHADER_MODEL >= 0x500)\n"
"#define FXAA_HLSL_5 1\n"
"#define FXAA_GATHER4_ALPHA 1\n"
"\n"
"#elif (SHADER_MODEL >= 0x400)\n"
"#define FXAA_HLSL_4 1\n"
"#define FXAA_GATHER4_ALPHA 0\n"
"\n"
"#elif (FXAA_GLSL_130 == 1)\n"
"#define FXAA_GATHER4_ALPHA 1\n"
"#endif\n"
"\n"
"#if (FXAA_HLSL_5 == 1)\n"
"struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
"#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
"#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
"#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n"
"#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n"
"#define FxaaDiscard clip(-1)\n"
"#define FxaaSat(x) saturate(x)\n"
"\n"
"#elif (FXAA_HLSL_4 == 1)\n"
"struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
"#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
"#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
"#define FxaaDiscard clip(-1)\n"
"#define FxaaSat(x) saturate(x)\n"
"\n"
"#elif (FXAA_GLSL_130 == 1)\n"
"#define int2 ivec2\n"
"#define float2 vec2\n"
"#define float3 vec3\n"
"#define float4 vec4\n"
"#define FxaaDiscard discard\n"
"#define FxaaSat(x) clamp(x, 0.0, 1.0)\n"
"#define FxaaTex sampler2D\n"
"#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n"
"#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n"
"\n"
"#if (FXAA_GATHER4_ALPHA == 1)\n"
"// use #extension GL_ARB_gpu_shader5 : enable\n"
"#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n"
"#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#define FxaaEdgeThreshold 0.063\n"
"#define FxaaEdgeThresholdMin 0.00\n"
"#define FXAA_QUALITY__P0 1.0\n"
"#define FXAA_QUALITY__P1 1.5\n"
"#define FXAA_QUALITY__P2 2.0\n"
"#define FXAA_QUALITY__P3 2.0\n"
"#define FXAA_QUALITY__P4 2.0\n"
"#define FXAA_QUALITY__P5 2.0\n"
"#define FXAA_QUALITY__P6 2.0\n"
"#define FXAA_QUALITY__P7 2.0\n"
"#define FXAA_QUALITY__P8 2.0\n"
"#define FXAA_QUALITY__P9 2.0\n"
"#define FXAA_QUALITY__P10 4.0\n"
"#define FXAA_QUALITY__P11 8.0\n"
"#define FXAA_QUALITY__P12 8.0\n"
"\n"
"/*------------------------------------------------------------------------------\n"
"                        [GAMMA PREPASS CODE SECTION]\n"
"------------------------------------------------------------------------------*/\n"
"float RGBLuminance(float3 color)\n"
"{\n"
"	const float3 lumCoeff = float3(0.2126729, 0.7151522, 0.0721750);\n"
"	return dot(color.rgb, lumCoeff);\n"
"}\n"
"\n"
"#if (FXAA_GLSL_130 == 0)\n"
"#define PixelSize float2(_rcpFrame.x, _rcpFrame.y)\n"
"#endif\n"
"\n"
"\n"
"float3 RGBGammaToLinear(float3 color, float gamma)\n"
"{\n"
"	color = FxaaSat(color);\n"
"	color.r = (color.r <= 0.0404482362771082) ?\n"
"	color.r / 12.92 : pow((color.r + 0.055) / 1.055, gamma);\n"
"	color.g = (color.g <= 0.0404482362771082) ?\n"
"	color.g / 12.92 : pow((color.g + 0.055) / 1.055, gamma);\n"
"	color.b = (color.b <= 0.0404482362771082) ?\n"
"	color.b / 12.92 : pow((color.b + 0.055) / 1.055, gamma);\n"
"\n"
"	return color;\n"
"}\n"
"\n"
"float3 LinearToRGBGamma(float3 color, float gamma)\n"
"{\n"
"	color = FxaaSat(color);\n"
"	color.r = (color.r <= 0.00313066844250063) ?\n"
"	color.r * 12.92 : 1.055 * pow(color.r, 1.0 / gamma) - 0.055;\n"
"	color.g = (color.g <= 0.00313066844250063) ?\n"
"	color.g * 12.92 : 1.055 * pow(color.g, 1.0 / gamma) - 0.055;\n"
"	color.b = (color.b <= 0.00313066844250063) ?\n"
"	color.b * 12.92 : 1.055 * pow(color.b, 1.0 / gamma) - 0.055;\n"
"\n"
"	return color;\n"
"}\n"
"\n"
"float4 PreGammaPass(float4 color, float2 uv0)\n"
"{\n"
"	#if (SHADER_MODEL >= 0x400)\n"
"		color = Texture.Sample(TextureSampler, uv0);\n"
"	#elif (FXAA_GLSL_130 == 1)\n"
"		color = texture(TextureSampler, uv0);\n"
"	#endif\n"
"\n"
"	const float GammaConst = 2.233;\n"
"	color.rgb = RGBGammaToLinear(color.rgb, GammaConst);\n"
"	color.rgb = LinearToRGBGamma(color.rgb, GammaConst);\n"
"	color.a = RGBLuminance(color.rgb);\n"
"\n"
"	return color;\n"
"}\n"
"\n"
"\n"
"/*------------------------------------------------------------------------------\n"
"                        [FXAA CODE SECTION]\n"
"------------------------------------------------------------------------------*/\n"
"\n"
"float FxaaLuma(float4 rgba)\n"
"{ \n"
"	rgba.w = RGBLuminance(rgba.xyz);\n"
"	return rgba.w; \n"
"}\n"
"\n"
"float4 FxaaPixelShader(float2 pos, FxaaTex tex, float2 fxaaRcpFrame, float fxaaSubpix, float fxaaEdgeThreshold, float fxaaEdgeThresholdMin)\n"
"{\n"
"	float2 posM;\n"
"	posM.x = pos.x;\n"
"	posM.y = pos.y;\n"
"\n"
"	#if (FXAA_GATHER4_ALPHA == 1)\n"
"	float4 rgbyM = FxaaTexTop(tex, posM);\n"
"	float4 luma4A = FxaaTexAlpha4(tex, posM);\n"
"	float4 luma4B = FxaaTexOffAlpha4(tex, posM, int2(-1, -1));\n"
"	rgbyM.w = RGBLuminance(rgbyM.xyz);\n"
"\n"
"	#define lumaM rgbyM.w\n"
"	#define lumaE luma4A.z\n"
"	#define lumaS luma4A.x\n"
"	#define lumaSE luma4A.y\n"
"	#define lumaNW luma4B.w\n"
"	#define lumaN luma4B.z\n"
"	#define lumaW luma4B.x\n"
"\n"
"	#else\n"
"	float4 rgbyM = FxaaTexTop(tex, posM);\n"
"	rgbyM.w = RGBLuminance(rgbyM.xyz);\n"
"	#define lumaM rgbyM.w\n"
"\n"
"	float lumaS = FxaaLuma(FxaaTexOff(tex, posM, int2( 0, 1), fxaaRcpFrame.xy));\n"
"	float lumaE = FxaaLuma(FxaaTexOff(tex, posM, int2( 1, 0), fxaaRcpFrame.xy));\n"
"	float lumaN = FxaaLuma(FxaaTexOff(tex, posM, int2( 0,-1), fxaaRcpFrame.xy));\n"
"	float lumaW = FxaaLuma(FxaaTexOff(tex, posM, int2(-1, 0), fxaaRcpFrame.xy));\n"
"	#endif\n"
"\n"
"	float maxSM = max(lumaS, lumaM);\n"
"	float minSM = min(lumaS, lumaM);\n"
"	float maxESM = max(lumaE, maxSM);\n"
"	float minESM = min(lumaE, minSM);\n"
"	float maxWN = max(lumaN, lumaW);\n"
"	float minWN = min(lumaN, lumaW);\n"
"\n"
"	float rangeMax = max(maxWN, maxESM);\n"
"	float rangeMin = min(minWN, minESM);\n"
"	float range = rangeMax - rangeMin;\n"
"	float rangeMaxScaled = rangeMax * fxaaEdgeThreshold;\n"
"	float rangeMaxClamped = max(fxaaEdgeThresholdMin, rangeMaxScaled);\n"
"\n"
"	bool earlyExit = range < rangeMaxClamped;\n"
"	#if (FxaaEarlyExit == 1)\n"
"	if(earlyExit) { return rgbyM; }\n"
"	#endif\n"
"\n"
"	#if (FXAA_GATHER4_ALPHA == 0)\n"
"	float lumaNW = FxaaLuma(FxaaTexOff(tex, posM, int2(-1,-1), fxaaRcpFrame.xy));\n"
"	float lumaSE = FxaaLuma(FxaaTexOff(tex, posM, int2( 1, 1), fxaaRcpFrame.xy));\n"
"	float lumaNE = FxaaLuma(FxaaTexOff(tex, posM, int2( 1,-1), fxaaRcpFrame.xy));\n"
"	float lumaSW = FxaaLuma(FxaaTexOff(tex, posM, int2(-1, 1), fxaaRcpFrame.xy));\n"
"	#else\n"
"	float lumaNE = FxaaLuma(FxaaTexOff(tex, posM, int2( 1,-1), fxaaRcpFrame.xy));\n"
"	float lumaSW = FxaaLuma(FxaaTexOff(tex, posM, int2(-1, 1), fxaaRcpFrame.xy));\n"
"	#endif\n"
"\n"
"	float lumaNS = lumaN + lumaS;\n"
"	float lumaWE = lumaW + lumaE;\n"
"	float subpixRcpRange = 1.0/range;\n"
"	float subpixNSWE = lumaNS + lumaWE;\n"
"	float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n"
"	float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n"
"	float lumaNESE = lumaNE + lumaSE;\n"
"	float lumaNWNE = lumaNW + lumaNE;\n"
"	float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n"
"	float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n"
"\n"
"	float lumaNWSW = lumaNW + lumaSW;\n"
"	float lumaSWSE = lumaSW + lumaSE;\n"
"	float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n"
"	float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n"
"	float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n"
"	float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n"
"	float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n"
"	float edgeVert = abs(edgeVert3) + edgeVert4;\n"
"\n"
"	float subpixNWSWNESE = lumaNWSW + lumaNESE;\n"
"	float lengthSign = fxaaRcpFrame.x;\n"
"	bool horzSpan = edgeHorz >= edgeVert;\n"
"	float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n"
"	if(!horzSpan) lumaN = lumaW;\n"
"	if(!horzSpan) lumaS = lumaE;\n"
"	if(horzSpan) lengthSign = fxaaRcpFrame.y;\n"
"	float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n"
"\n"
"	float gradientN = lumaN - lumaM;\n"
"	float gradientS = lumaS - lumaM;\n"
"	float lumaNN = lumaN + lumaM;\n"
"	float lumaSS = lumaS + lumaM;\n"
"	bool pairN = abs(gradientN) >= abs(gradientS);\n"
"	float gradient = max(abs(gradientN), abs(gradientS));\n"
"	if(pairN) lengthSign = -lengthSign;\n"
"	float subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n"
"\n"
"	float2 posB;\n"
"	posB.x = posM.x;\n"
"	posB.y = posM.y;\n"
"	float2 offNP;\n"
"	offNP.x = (!horzSpan) ? 0.0 : fxaaRcpFrame.x;\n"
"	offNP.y = ( horzSpan) ? 0.0 : fxaaRcpFrame.y;\n"
"	if(!horzSpan) posB.x += lengthSign * 0.5;\n"
"	if( horzSpan) posB.y += lengthSign * 0.5;\n"
"\n"
"	float2 posN;\n"
"	posN.x = posB.x - offNP.x * FXAA_QUALITY__P0;\n"
"	posN.y = posB.y - offNP.y * FXAA_QUALITY__P0;\n"
"	float2 posP;\n"
"	posP.x = posB.x + offNP.x * FXAA_QUALITY__P0;\n"
"	posP.y = posB.y + offNP.y * FXAA_QUALITY__P0;\n"
"	float subpixD = ((-2.0)*subpixC) + 3.0;\n"
"	float lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n"
"	float subpixE = subpixC * subpixC;\n"
"	float lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n"
"\n"
"	if(!pairN) lumaNN = lumaSS;\n"
"	float gradientScaled = gradient * 1.0/4.0;\n"
"	float lumaMM = lumaM - lumaNN * 0.5;\n"
"	float subpixF = subpixD * subpixE;\n"
"	bool lumaMLTZero = lumaMM < 0.0;\n"
"	lumaEndN -= lumaNN * 0.5;\n"
"	lumaEndP -= lumaNN * 0.5;\n"
"	bool doneN = abs(lumaEndN) >= gradientScaled;\n"
"	bool doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;\n"
"	bool doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P2;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P2;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P2;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P2;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P3;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P3;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P3;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P3;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P4;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P4;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P4;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P4;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P5;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P5;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P5;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P5;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P6;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P6;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P6;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P6;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P7;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P7;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P7;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P7;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P8;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P8;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P8;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P8;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P9;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P9;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P9;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P9;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P10;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P10;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P10;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P10;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;\n"
"\n"
"	if(doneNP) {\n"
"	if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
"	if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
"	if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
"	if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
"	doneN = abs(lumaEndN) >= gradientScaled;\n"
"	doneP = abs(lumaEndP) >= gradientScaled;\n"
"	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P12;\n"
"	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P12;\n"
"	doneNP = (!doneN) || (!doneP);\n"
"	if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P12;\n"
"	if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P12;\n"
"	}}}}}}}}}}}\n"
"\n"
"	float dstN = posM.x - posN.x;\n"
"	float dstP = posP.x - posM.x;\n"
"	if(!horzSpan) dstN = posM.y - posN.y;\n"
"	if(!horzSpan) dstP = posP.y - posM.y;\n"
"\n"
"	bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n"
"	float spanLength = (dstP + dstN);\n"
"	bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n"
"	float spanLengthRcp = 1.0/spanLength;\n"
"\n"
"	bool directionN = dstN < dstP;\n"
"	float dst = min(dstN, dstP);\n"
"	bool goodSpan = directionN ? goodSpanN : goodSpanP;\n"
"	float subpixG = subpixF * subpixF;\n"
"	float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n"
"	float subpixH = subpixG * fxaaSubpix;\n"
"\n"
"	float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n"
"	float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n"
"	if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n"
"	if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n"
"\n"
"	return float4(FxaaTexTop(tex, posM).xyz, lumaM);\n"
"}\n"
"\n"
"#if (FXAA_GLSL_130 == 1)\n"
"float4 FxaaPass(float4 FxaaColor, float2 uv0)\n"
"#elif (SHADER_MODEL >= 0x400)\n"
"float4 FxaaPass(float4 FxaaColor : COLOR0, float2 uv0 : TEXCOORD0)\n"
"#endif\n"
"{\n"
"\n"
"	#if (SHADER_MODEL >= 0x400)\n"
"	FxaaTex tex;\n"
"	tex.tex = Texture;\n"
"	tex.smpl = TextureSampler;\n"
"\n"
"	Texture.GetDimensions(PixelSize.x, PixelSize.y);\n"
"	FxaaColor = FxaaPixelShader(uv0, tex, 1.0/PixelSize.xy, FxaaSubpixMax, FxaaEdgeThreshold, FxaaEdgeThresholdMin);\n"
"\n"
"	#elif (FXAA_GLSL_130 == 1)\n"
"	vec2 PixelSize = textureSize(TextureSampler, 0);\n"
"	FxaaColor = FxaaPixelShader(uv0, TextureSampler, 1.0/PixelSize.xy, FxaaSubpixMax, FxaaEdgeThreshold, FxaaEdgeThresholdMin);\n"
"	#endif\n"
"\n"
"	return FxaaColor;\n"
"}\n"
"\n"
"/*------------------------------------------------------------------------------\n"
"                      [MAIN() & COMBINE PASS CODE SECTION]\n"
"------------------------------------------------------------------------------*/\n"
"#if (FXAA_GLSL_130 == 1)\n"
"\n"
"void ps_main()\n"
"{\n"
"	vec4 color = texture(TextureSampler, PSin.t);\n"
"	color      = PreGammaPass(color, PSin.t);\n"
"	color      = FxaaPass(color, PSin.t);\n"
"\n"
"	SV_Target0 = color;\n"
"}\n"
"\n"
"#elif (SHADER_MODEL >= 0x400)\n"
"PS_OUTPUT ps_main(VS_OUTPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	float4 color = Texture.Sample(TextureSampler, input.t);\n"
"\n"
"	color = PreGammaPass(color, input.t);\n"
"	color = FxaaPass(color, input.t);\n"
"\n"
"	output.c = color;\n"
"	\n"
"	return output;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#endif\n"
;

