char convert_fx_shader_raw[] = 
"#ifdef SHADER_MODEL // make safe to include in resource file to enforce dependency\n"
"\n"
"struct VS_INPUT\n"
"{\n"
"	float4 p : POSITION;\n"
"	float2 t : TEXCOORD0;\n"
"	float4 c : COLOR;\n"
"};\n"
"\n"
"struct VS_OUTPUT\n"
"{\n"
"	float4 p : SV_Position;\n"
"	float2 t : TEXCOORD0;\n"
"	float4 c : COLOR;\n"
"};\n"
"\n"
"cbuffer cb0 : register(b0)\n"
"{\n"
"	float4 BGColor;\n"
"	int EMODA;\n"
"	int EMODC;\n"
"	int DOFFSET;\n"
"};\n"
"\n"
"static const float3x3 rgb2yuv =\n"
"{\n"
"	{0.587, 0.114, 0.299},\n"
"	{-0.311, 0.500, -0.169},\n"
"	{-0.419, -0.081, 0.500}\n"
"};\n"
"\n"
"Texture2D Texture;\n"
"SamplerState TextureSampler;\n"
"\n"
"float4 sample_c(float2 uv)\n"
"{\n"
"	return Texture.Sample(TextureSampler, uv);\n"
"}\n"
"\n"
"struct PS_INPUT\n"
"{\n"
"	float4 p : SV_Position;\n"
"	float2 t : TEXCOORD0;\n"
"	float4 c : COLOR;\n"
"};\n"
"\n"
"struct PS_OUTPUT\n"
"{\n"
"	float4 c : SV_Target0;\n"
"};\n"
"\n"
"VS_OUTPUT vs_main(VS_INPUT input)\n"
"{\n"
"	VS_OUTPUT output;\n"
"\n"
"	output.p = input.p;\n"
"	output.t = input.t;\n"
"	output.c = input.c;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_copy(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	\n"
"	output.c = sample_c(input.t);\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"float ps_depth_copy(PS_INPUT input) : SV_Depth\n"
"{\n"
"	return sample_c(input.t).r;\n"
"}\n"
"\n"
"PS_OUTPUT ps_downsample_copy(PS_INPUT input)\n"
"{\n"
"	int DownsampleFactor = DOFFSET;\n"
"	int2 ClampMin = int2(EMODA, EMODC);\n"
"	float Weight = BGColor.x;\n"
"\n"
"	int2 coord = max(int2(input.p.xy) * DownsampleFactor, ClampMin);\n"
"\n"
"	PS_OUTPUT output;\n"
"	output.c = (float4)0;\n"
"	for (int yoff = 0; yoff < DownsampleFactor; yoff++)\n"
"	{\n"
"		for (int xoff = 0; xoff < DownsampleFactor; xoff++)\n"
"			output.c += Texture.Load(int3(coord + int2(xoff, yoff), 0));\n"
"	}\n"
"	output.c /= Weight;\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_filter_transparency(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	float4 c = sample_c(input.t);\n"
"	output.c = float4(c.rgb, 1.0);\n"
"	return output;\n"
"}\n"
"\n"
"// Need to be careful with precision here, it can break games like Spider-Man 3 and Dogs Life\n"
"uint ps_convert_rgba8_16bits(PS_INPUT input) : SV_Target0\n"
"{\n"
"	uint4 i = sample_c(input.t) * float4(255.5f, 255.5f, 255.5f, 255.5f);\n"
"\n"
"	return ((i.x & 0x00F8u) >> 3) | ((i.y & 0x00F8u) << 2) | ((i.z & 0x00f8u) << 7) | ((i.w & 0x80u) << 8);\n"
"}\n"
"\n"
"PS_OUTPUT ps_datm1(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	\n"
"	clip(sample_c(input.t).a - 127.5f / 255); // >= 0x80 pass\n"
"	\n"
"	output.c = 0;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_datm0(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	\n"
"	clip(127.5f / 255 - sample_c(input.t).a); // < 0x80 pass (== 0x80 should not pass)\n"
"	\n"
"	output.c = 0;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_datm1_rta_correction(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	clip(sample_c(input.t).a - 254.5f / 255); // >= 0x80 pass\n"
"\n"
"	output.c = 0;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_datm0_rta_correction(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	clip(254.5f / 255 - sample_c(input.t).a); // < 0x80 pass (== 0x80 should not pass)\n"
"\n"
"	output.c = 0;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_rta_correction(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	float4 value = sample_c(input.t);\n"
"	output.c = float4(value.rgb, value.a / (128.25f / 255.0f));\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_rta_decorrection(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	float4 value = sample_c(input.t);\n"
"	output.c = float4(value.rgb, value.a * (128.25f / 255.0f));\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_hdr_init(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	float4 value = sample_c(input.t);\n"
"	output.c = float4(round(value.rgb * 255) / 65535, value.a);\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_hdr_resolve(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"	float4 value = sample_c(input.t);\n"
"	output.c = float4(float3(uint3(value.rgb * 65535.5) & 255) / 255, value.a);\n"
"	return output;\n"
"}\n"
"\n"
"uint ps_convert_float32_32bits(PS_INPUT input) : SV_Target0\n"
"{\n"
"	// Convert a FLOAT32 depth texture into a 32 bits UINT texture\n"
"	return uint(exp2(32.0f) * sample_c(input.t).r);\n"
"}\n"
"\n"
"PS_OUTPUT ps_convert_float32_rgba8(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	// Convert a FLOAT32 depth texture into a RGBA color texture\n"
"	uint d = uint(sample_c(input.t).r * exp2(32.0f));\n"
"	output.c = float4(uint4((d & 0xFFu), ((d >> 8) & 0xFFu), ((d >> 16) & 0xFFu), (d >> 24))) / 255.0f;\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_convert_float16_rgb5a1(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	// Convert a FLOAT32 (only 16 lsb) depth into a RGB5A1 color texture\n"
"	uint d = uint(sample_c(input.t).r * exp2(32.0f));\n"
"	output.c = float4(uint4(d << 3, d >> 2, d >> 7, d >> 8) & uint4(0xf8, 0xf8, 0xf8, 0x80)) / 255.0f;\n"
"	return output;\n"
"}\n"
"\n"
"float rgba8_to_depth32(float4 val)\n"
"{\n"
"	uint4 c = uint4(val * 255.5f);\n"
"	return float(c.r | (c.g << 8) | (c.b << 16) | (c.a << 24)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgba8_to_depth24(float4 val)\n"
"{\n"
"	uint3 c = uint3(val.rgb * 255.5f);\n"
"	return float(c.r | (c.g << 8) | (c.b << 16)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgba8_to_depth16(float4 val)\n"
"{\n"
"	uint2 c = uint2(val.rg * 255.5f);\n"
"	return float(c.r | (c.g << 8)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgb5a1_to_depth16(float4 val)\n"
"{\n"
"	uint4 c = uint4(val * 255.5f);\n"
"	return float(((c.r & 0xF8u) >> 3) | ((c.g & 0xF8u) << 2) | ((c.b & 0xF8u) << 7) | ((c.a & 0x80u) << 8)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float ps_convert_float32_float24(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Truncates depth value to 24bits\n"
"	uint d = uint(sample_c(input.t).r * exp2(32.0f)) & 0xFFFFFFu;\n"
"	return float(d) * exp2(-32.0f);\n"
"}\n"
"\n"
"float ps_convert_rgba8_float32(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	return rgba8_to_depth32(sample_c(input.t));\n"
"}\n"
"\n"
"float ps_convert_rgba8_float24(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	return rgba8_to_depth24(sample_c(input.t));\n"
"}\n"
"\n"
"float ps_convert_rgba8_float16(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	return rgba8_to_depth16(sample_c(input.t));\n"
"}\n"
"\n"
"float ps_convert_rgb5a1_float16(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	return rgb5a1_to_depth16(sample_c(input.t));\n"
"}\n"
"\n"
"#define SAMPLE_RGBA_DEPTH_BILN(CONVERT_FN) uint width, height; Texture.GetDimensions(width, height); float2 top_left_f = input.t * float2(width, height) - 0.5f; int2 top_left = int2(floor(top_left_f)); int4 coords = clamp(int4(top_left, top_left + 1), int4(0, 0, 0, 0), int2(width - 1, height - 1).xyxy); float2 mix_vals = frac(top_left_f); float depthTL = CONVERT_FN(Texture.Load(int3(coords.xy, 0))); float depthTR = CONVERT_FN(Texture.Load(int3(coords.zy, 0))); float depthBL = CONVERT_FN(Texture.Load(int3(coords.xw, 0))); float depthBR = CONVERT_FN(Texture.Load(int3(coords.zw, 0))); return lerp(lerp(depthTL, depthTR, mix_vals.x), lerp(depthBL, depthBR, mix_vals.x), mix_vals.y);\n"
"\n"
"float ps_convert_rgba8_float32_biln(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth32);\n"
"}\n"
"\n"
"float ps_convert_rgba8_float24_biln(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth24);\n"
"}\n"
"\n"
"float ps_convert_rgba8_float16_biln(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth16);\n"
"}\n"
"\n"
"float ps_convert_rgb5a1_float16_biln(PS_INPUT input) : SV_Depth\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgb5a1_to_depth16);\n"
"}\n"
"\n"
"PS_OUTPUT ps_convert_rgba_8i(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	// Convert a RGBA texture into a 8 bits packed texture\n"
"	// Input column: 8x2 RGBA pixels\n"
"	// 0: 8 RGBA\n"
"	// 1: 8 RGBA\n"
"	// Output column: 16x4 Index pixels\n"
"	// 0: 8 R | 8 B\n"
"	// 1: 8 R | 8 B\n"
"	// 2: 8 G | 8 A\n"
"	// 3: 8 G | 8 A\n"
"	uint2 pos = uint2(input.p.xy);\n"
"\n"
"	// Collapse separate R G B A areas into their base pixel\n"
"	uint2 block = (pos & ~uint2(15u, 3u)) >> 1;\n"
"	uint2 subblock = pos & uint2(7u, 1u);\n"
"	uint2 coord = block | subblock;\n"
"\n"
"	// Compensate for potentially differing page pitch.\n"
"	uint SBW = uint(EMODA);\n"
"	uint DBW = uint(EMODC);\n"
"	uint2 block_xy = coord / uint2(64, 32);\n"
"	uint block_num = (block_xy.y * (DBW / 128)) + block_xy.x;\n"
"	uint2 block_offset = uint2((block_num % (SBW / 64)) * 64, (block_num / (SBW / 64)) * 32);\n"
"	coord = (coord % uint2(64, 32)) + block_offset;\n"
"\n"
"	// Apply offset to cols 1 and 2\n"
"	uint is_col23 = pos.y & 4u;\n"
"	uint is_col13 = pos.y & 2u;\n"
"	uint is_col12 = is_col23 ^ (is_col13 << 1);\n"
"	coord.x ^= is_col12; // If cols 1 or 2, flip bit 3 of x\n"
"\n"
"	float ScaleFactor = BGColor.x;\n"
"	if (floor(ScaleFactor) != ScaleFactor)\n"
"		coord = uint2(float2(coord) * ScaleFactor);\n"
"	else\n"
"		coord *= uint(ScaleFactor);\n"
"\n"
"	float4 pixel = Texture.Load(int3(int2(coord), 0));\n"
"	float2 sel0 = (pos.y & 2u) == 0u ? pixel.rb : pixel.ga;\n"
"	float  sel1 = (pos.x & 8u) == 0u ? sel0.x : sel0.y;\n"
"	output.c = (float4)(sel1); // Divide by something here?\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_convert_clut_4(PS_INPUT input)\n"
"{\n"
"	// Borrowing the YUV constant buffer.\n"
"	float scale = BGColor.x;\n"
"	uint2 offset = uint2(uint(EMODA), uint(EMODC)) + uint(DOFFSET);\n"
"\n"
"	// CLUT4 is easy, just two rows of 8x8.\n"
"	uint index = uint(input.p.x);\n"
"	uint2 pos = uint2(index % 8u, index / 8u);\n"
"\n"
"	int2 final = int2(floor(float2(offset + pos) * scale));\n"
"	PS_OUTPUT output;\n"
"	output.c = Texture.Load(int3(final, 0), 0);\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_convert_clut_8(PS_INPUT input)\n"
"{\n"
"	float scale = BGColor.x;\n"
"	uint2 offset = uint2(uint(EMODA), uint(EMODC));\n"
"	uint index = min(uint(input.p.x) + uint(DOFFSET), 255u);\n"
"\n"
"	// CLUT is arranged into 8 groups of 16x2, with the top-right and bottom-left quadrants swapped.\n"
"	// This can probably be done better..\n"
"	uint subgroup = (index / 8u) % 4u;\n"
"	uint2 pos;\n"
"	pos.x = (index % 8u) + ((subgroup >= 2u) ? 8u : 0u);\n"
"	pos.y = ((index / 32u) * 2u) + (subgroup % 2u);\n"
"\n"
"	int2 final = int2(floor(float2(offset + pos) * scale));\n"
"	PS_OUTPUT output;\n"
"	output.c = Texture.Load(int3(final, 0), 0);\n"
"	return output;\n"
"}\n"
"\n"
"PS_OUTPUT ps_yuv(PS_INPUT input)\n"
"{\n"
"	PS_OUTPUT output;\n"
"\n"
"	float4 i = sample_c(input.t);\n"
"	float3 yuv = mul(rgb2yuv, i.gbr);\n"
"\n"
"	float Y = float(0xDB) / 255.0f * yuv.x + float(0x10) / 255.0f;\n"
"	float Cr = float(0xE0) / 255.0f * yuv.y + float(0x80) / 255.0f;\n"
"	float Cb = float(0xE0) / 255.0f * yuv.z + float(0x80) / 255.0f;\n"
"\n"
"	switch (EMODA)\n"
"	{\n"
"		case 0:\n"
"			output.c.a = i.a;\n"
"			break;\n"
"		case 1:\n"
"			output.c.a = Y;\n"
"			break;\n"
"		case 2:\n"
"			output.c.a = Y / 2.0f;\n"
"			break;\n"
"		case 3:\n"
"		default:\n"
"			output.c.a = 0.0f;\n"
"			break;\n"
"	}\n"
"\n"
"	switch (EMODC)\n"
"	{\n"
"		case 0:\n"
"			output.c.rgb = i.rgb;\n"
"			break;\n"
"		case 1:\n"
"			output.c.rgb = float3(Y, Y, Y);\n"
"			break;\n"
"		case 2:\n"
"			output.c.rgb = float3(Y, Cb, Cr);\n"
"			break;\n"
"		case 3:\n"
"		default:\n"
"			output.c.rgb = float3(i.a, i.a, i.a);\n"
"			break;\n"
"	}\n"
"\n"
"	return output;\n"
"}\n"
"\n"
"float ps_stencil_image_init_0(PS_INPUT input) : SV_Target\n"
"{\n"
"	float c;\n"
"	if ((127.5f / 255.0f) < sample_c(input.t).a) // < 0x80 pass (== 0x80 should not pass)\n"
"		c = float(-1);\n"
"	else\n"
"		c = float(0x7FFFFFFF);\n"
"	return c;\n"
"}\n"
"\n"
"float ps_stencil_image_init_1(PS_INPUT input) : SV_Target\n"
"{\n"
"	float c;\n"
"	if (sample_c(input.t).a < (127.5f / 255.0f)) // >= 0x80 pass\n"
"		c = float(-1);\n"
"	else\n"
"		c = float(0x7FFFFFFF);\n"
"	return c;\n"
"}\n"
"\n"
"float ps_stencil_image_init_2(PS_INPUT input)\n"
"	: SV_Target\n"
"{\n"
"	float c;\n"
"	if ((254.5f / 255.0f) < sample_c(input.t).a) // < 0x80 pass (== 0x80 should not pass)\n"
"		c = float(-1);\n"
"	else\n"
"		c = float(0x7FFFFFFF);\n"
"	return c;\n"
"}\n"
"\n"
"float ps_stencil_image_init_3(PS_INPUT input)\n"
"	: SV_Target\n"
"{\n"
"	float c;\n"
"	if (sample_c(input.t).a < (254.5f / 255.0f)) // >= 0x80 pass\n"
"		c = float(-1);\n"
"	else\n"
"		c = float(0x7FFFFFFF);\n"
"	return c;\n"
"}\n"
"\n"
"#endif\n"
;
