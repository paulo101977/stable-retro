char interlace_fx_shader_raw[] = 
"#ifdef SHADER_MODEL // make safe to include in resource file to enforce dependency\n"
"\n"
"Texture2D Texture;\n"
"SamplerState Sampler;\n"
"\n"
"cbuffer cb0\n"
"{\n"
"	float4 ZrH;\n"
"};\n"
"\n"
"struct PS_INPUT\n"
"{\n"
"	float4 p : SV_Position;\n"
"	float2 t : TEXCOORD0;\n"
"};\n"
"\n"
"\n"
"// Weave shader\n"
"float4 ps_main0(PS_INPUT input) : SV_Target0\n"
"{\n"
"	const int idx   = int(ZrH.x);     // buffer index passed from CPU\n"
"	const int field = idx & 1;        // current field\n"
"	const int vpos  = int(input.p.y); // vertical position of destination texture\n"
"\n"
"	if ((vpos & 1) == field)\n"
"		return Texture.SampleLevel(Sampler, input.t, 0);\n"
"	else\n"
"		discard;\n"
"\n"
"	return float4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"}\n"
"\n"
"\n"
"// Bob shader\n"
"float4 ps_main1(PS_INPUT input) : SV_Target0\n"
"{\n"
"	return Texture.SampleLevel(Sampler, input.t, 0);\n"
"}\n"
"\n"
"\n"
"// Blend shader\n"
"float4 ps_main2(PS_INPUT input) : SV_Target0\n"
"{\n"
"	float2 vstep = float2(0.0f, ZrH.y);\n"
"	float4 c0 = Texture.SampleLevel(Sampler, input.t - vstep, 0);\n"
"	float4 c1 = Texture.SampleLevel(Sampler, input.t, 0);\n"
"	float4 c2 = Texture.SampleLevel(Sampler, input.t + vstep, 0);\n"
"\n"
"	return (c0 + c1 * 2 + c2) / 4;\n"
"}\n"
"\n"
"\n"
"// MAD shader - buffering\n"
"float4 ps_main3(PS_INPUT input) : SV_Target0\n"
"{\n"
"	// We take half the lines from the current frame and stores them in the MAD frame buffer.\n"
"	// the MAD frame buffer is split in 2 consecutive banks of 2 fields each, the fields in each bank\n"
"	// are interleaved (top field at even lines and bottom field at odd lines). \n"
"	// When the source texture has an odd vres, the first line of bank 1 would be an odd index\n"
"	// causing the wrong lines to be discarded, so a vertical offset (lofs) is added to the vertical\n"
"	// position of the destination texture to force the proper field alignment\n"
"\n"
"	const int    idx    = int(ZrH.x);                                // buffer index passed from CPU\n"
"	const int    bank   = idx >> 1;                                  // current bank\n"
"	const int    field  = idx & 1;                                   // current field\n"
"	const int    vres   = int(ZrH.z) >> 1;                           // vertical resolution of source texture\n"
"	const int    lofs   = ((((vres + 1) >> 1) << 1) - vres) & bank;  // line alignment offset for bank 1\n"
"	const int    vpos   = int(input.p.y) + lofs;                     // vertical position of destination texture\n"
"\n"
"	// if the index of current destination line belongs to the current fiels we update it, otherwise\n"
"	// we leave the old line in the destination buffer\n"
"	if ((vpos & 1) == field)\n"
"		return Texture.SampleLevel(Sampler, input.t, 0);\n"
"	else\n"
"		discard;\n"
"\n"
"	return float4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"}\n"
"\n"
"\n"
"// MAD shader - reconstruction\n"
"float4 ps_main4(PS_INPUT input) : SV_Target0\n"
"{\n"
"	// we use the contents of the MAD frame buffer to reconstruct the missing lines from the current\n"
"	// field.\n"
"\n"
"	const int    idx         = int(ZrH.x);                          // buffer index passed from CPU\n"
"	const int    field       = idx & 1;                             // current field\n"
"	const int    vpos        = int(input.p.y);                      // vertical position of destination texture\n"
"	const float  sensitivity = ZrH.w;                               // passed from CPU, higher values mean more likely to use weave\n"
"	const float3 motion_thr  = float3(1.0, 1.0, 1.0) * sensitivity; //\n"
"	const float2 bofs        = float2(0.0f, 0.5f);                  // position of the bank 1 relative to source texture size\n"
"	const float2 vscale      = float2(1.0f, 0.5f);                  // scaling factor from source to destination texture\n"
"	const float2 lofs        = float2(0.0f, ZrH.y) * vscale;        // distance between two adjacent lines relative to source texture size\n"
"	const float2 iptr        = input.t * vscale;                    // pointer to the current pixel in the source texture\n"
"\n"
"	float2 p_t0; // pointer to current pixel (missing or not) from most recent frame\n"
"	float2 p_t1; // pointer to current pixel (missing or not) from one frame back\n"
"	float2 p_t2; // pointer to current pixel (missing or not) from two frames back\n"
"	float2 p_t3; // pointer to current pixel (missing or not) from three frames back\n"
"\n"
"	switch (idx)\n"
"	{\n"
"		case 1:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 2:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 3:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"		default:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"	}\n"
"\n"
"	// calculating motion, only relevant for missing lines where the center line is pointed by p_t1\n"
"\n"
"	float4 hn = Texture.SampleLevel(Sampler, p_t0 - lofs, 0); // new high pixel\n"
"	float4 cn = Texture.SampleLevel(Sampler, p_t1, 0);        // new center pixel\n"
"	float4 ln = Texture.SampleLevel(Sampler, p_t0 + lofs, 0); // new low pixel\n"
"\n"
"	float4 ho = Texture.SampleLevel(Sampler, p_t2 - lofs, 0); // old high pixel\n"
"	float4 co = Texture.SampleLevel(Sampler, p_t3, 0);        // old center pixel\n"
"	float4 lo = Texture.SampleLevel(Sampler, p_t2 + lofs, 0); // old low pixel\n"
"\n"
"	float3 mh = hn.rgb - ho.rgb; // high pixel motion\n"
"	float3 mc = cn.rgb - co.rgb; // center pixel motion\n"
"	float3 ml = ln.rgb - lo.rgb; // low pixel motion\n"
"\n"
"	mh = max(mh, -mh) - motion_thr;\n"
"	mc = max(mc, -mc) - motion_thr;\n"
"	ml = max(ml, -ml) - motion_thr;\n"
"\n"
"	#if 1 // use this code to evaluate each color motion separately\n"
"		float mh_max = max(max(mh.x, mh.y), mh.z);\n"
"		float mc_max = max(max(mc.x, mc.y), mc.z);\n"
"		float ml_max = max(max(ml.x, ml.y), ml.z);\n"
"	#else // use this code to evaluate average color motion\n"
"		float mh_max = mh.x + mh.y + mh.z;\n"
"		float mc_max = mc.x + mc.y + mc.z;\n"
"		float ml_max = ml.x + ml.y + ml.z;\n"
"	#endif\n"
"\n"
"	// selecting deinterlacing output\n"
"\n"
"	if ((vpos & 1) == field)\n"
"	{\n"
"		// output coordinate present on current field\n"
"		return Texture.SampleLevel(Sampler, p_t0, 0);\n"
"	}\n"
"	else if ((iptr.y > 0.5f - lofs.y) || (iptr.y < 0.0 + lofs.y))\n"
"	{\n"
"		// top and bottom lines are always weaved\n"
"		return cn;\n"
"	}\n"
"	else\n"
"	{\n"
"		// missing line needs to be reconstructed\n"
"		if (((mh_max > 0.0f) || (ml_max > 0.0f)) || (mc_max > 0.0f))\n"
"			// high motion -> interpolate pixels above and below\n"
"			return (hn + ln) / 2.0f;\n"
"		else\n"
"			// low motion -> weave\n"
"			return cn;\n"
"	}\n"
"\n"
"	return float4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"}\n"
"\n"
"#endif\n"
;
