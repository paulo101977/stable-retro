static const char tfx_vs_glsl_shader_raw[] = 
"layout(std140, binding = 1) uniform cb20\n"
"{\n"
"    vec2  VertexScale;\n"
"    vec2  VertexOffset;\n"
"\n"
"    vec2  TextureScale;\n"
"    vec2  TextureOffset;\n"
"\n"
"    vec2  PointSize;\n"
"    uint  MaxDepth;\n"
"    uint  pad_cb20;\n"
"};\n"
"\n"
"#ifdef VERTEX_SHADER\n"
"\n"
"out SHADER\n"
"{\n"
"    vec4 t_float;\n"
"    vec4 t_int;\n"
"    #if VS_IIP != 0\n"
"      vec4 c;\n"
"    #else\n"
"      flat vec4 c;\n"
"    #endif\n"
"} VSout;\n"
"\n"
"const float exp_min32 = exp2(-32.0f);\n"
"\n"
"#if VS_EXPAND == 0\n"
"\n"
"layout(location = 0) in vec2  i_st;\n"
"layout(location = 2) in vec4  i_c;\n"
"layout(location = 3) in float i_q;\n"
"layout(location = 4) in uvec2 i_p;\n"
"layout(location = 5) in uint  i_z;\n"
"layout(location = 6) in uvec2 i_uv;\n"
"layout(location = 7) in vec4  i_f;\n"
"\n"
"void texture_coord()\n"
"{\n"
"    vec2 uv = vec2(i_uv) - TextureOffset;\n"
"    vec2 st = i_st - TextureOffset;\n"
"\n"
"    // Float coordinate\n"
"    VSout.t_float.xy = st;\n"
"    VSout.t_float.w  = i_q;\n"
"\n"
"    // Integer coordinate => normalized\n"
"    VSout.t_int.xy = uv * TextureScale;\n"
"#if VS_FST\n"
"    // Integer coordinate => integral\n"
"    VSout.t_int.zw = uv;\n"
"#else\n"
"    // Some games uses float coordinate for post-processing effect\n"
"    VSout.t_int.zw = st / TextureScale;\n"
"#endif\n"
"}\n"
"\n"
"void vs_main()\n"
"{\n"
"    // Clamp to max depth, gs doesn't wrap\n"
"    highp uint z = min(i_z, MaxDepth);\n"
"\n"
"    // pos -= 0.05 (1/320 pixel) helps avoiding rounding problems (integral part of pos is usually 5 digits, 0.05 is about as low as we can go)\n"
"    // example: ceil(afterseveralvertextransformations(y = 133)) => 134 => line 133 stays empty\n"
"    // input granularity is 1/16 pixel, anything smaller than that won't step drawing up/left by one pixel\n"
"    // example: 133.0625 (133 + 1/16) should start from line 134, ceil(133.0625 - 0.05) still above 133\n"
"    vec4 p;\n"
"\n"
"    p.xy = vec2(i_p) - vec2(0.05f, 0.05f);\n"
"    p.xy = p.xy * VertexScale - VertexOffset;\n"
"    p.w = 1.0f;\n"
"\n"
"#if HAS_CLIP_CONTROL\n"
"    p.z = float(z) * exp_min32;\n"
"#else\n"
"    // GLES doesn't support ARB_clip_control, so remap it to -1..1. We also reduce the range from 32 bits\n"
"    // to 24 bits, which means some games with very large depth ranges will not render correctly. But,\n"
"    // for most, it's okay, and really, the best we can do.\n"
"    p.z = min(float(z) * exp2(-23.0f), 2.0f) - 1.0f;\n"
"#endif\n"
"\n"
"    gl_Position = p;\n"
"\n"
"    texture_coord();\n"
"\n"
"    VSout.c = i_c;\n"
"    VSout.t_float.z = i_f.x; // pack for with texture\n"
"\n"
"    #if VS_POINT_SIZE\n"
"        gl_PointSize = PointSize.x;\n"
"    #endif\n"
"}\n"
"\n"
"#else // VS_EXPAND\n"
"\n"
"struct RawVertex\n"
"{\n"
"    vec2 ST;\n"
"    uint RGBA;\n"
"    float Q;\n"
"    uint XY;\n"
"    uint Z;\n"
"    uint UV;\n"
"    uint FOG;\n"
"};\n"
"\n"
"layout(std140, binding = 2) readonly buffer VertexBuffer {\n"
"    RawVertex vertex_buffer[];\n"
"};\n"
"\n"
"struct ProcessedVertex\n"
"{\n"
"    vec4 p;\n"
"    vec4 t_float;\n"
"    vec4 t_int;\n"
"    vec4 c;\n"
"};\n"
"\n"
"ProcessedVertex load_vertex(uint index)\n"
"{\n"
"#if defined(GL_ARB_shader_draw_parameters) && GL_ARB_shader_draw_parameters\n"
"    RawVertex rvtx = vertex_buffer[index + gl_BaseVertexARB];\n"
"#else\n"
"    RawVertex rvtx = vertex_buffer[index];\n"
"#endif\n"
"\n"
"    vec2 i_st = rvtx.ST;\n"
"    vec4 i_c = vec4(uvec4(bitfieldExtract(rvtx.RGBA, 0, 8), bitfieldExtract(rvtx.RGBA, 8, 8),\n"
"	                      bitfieldExtract(rvtx.RGBA, 16, 8), bitfieldExtract(rvtx.RGBA, 24, 8)));\n"
"    float i_q = rvtx.Q;\n"
"    uvec2 i_p = uvec2(bitfieldExtract(rvtx.XY, 0, 16), bitfieldExtract(rvtx.XY, 16, 16));\n"
"    uint i_z = rvtx.Z;\n"
"    uvec2 i_uv = uvec2(bitfieldExtract(rvtx.UV, 0, 16), bitfieldExtract(rvtx.UV, 16, 16));\n"
"    vec4 i_f = unpackUnorm4x8(rvtx.FOG);\n"
"\n"
"    ProcessedVertex vtx;\n"
"\n"
"    uint z = min(i_z, MaxDepth);\n"
"    vtx.p.xy = vec2(i_p) - vec2(0.05f, 0.05f);\n"
"    vtx.p.xy = vtx.p.xy * VertexScale - VertexOffset;\n"
"    vtx.p.w = 1.0f;\n"
"\n"
"#if HAS_CLIP_CONTROL\n"
"    vtx.p.z = float(z) * exp_min32;\n"
"#else\n"
"    vtx.p.z = min(float(z) * exp2(-23.0f), 2.0f) - 1.0f;\n"
"#endif\n"
"\n"
"    vec2 uv = vec2(i_uv) - TextureOffset;\n"
"    vec2 st = i_st - TextureOffset;\n"
"\n"
"    vtx.t_float.xy = st;\n"
"    vtx.t_float.w  = i_q;\n"
"\n"
"    vtx.t_int.xy = uv * TextureScale;\n"
"#if VS_FST\n"
"    vtx.t_int.zw = uv;\n"
"#else\n"
"    vtx.t_int.zw = st / TextureScale;\n"
"#endif\n"
"\n"
"    vtx.c = i_c;\n"
"    vtx.t_float.z = i_f.x;\n"
"\n"
"    return vtx;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    ProcessedVertex vtx;\n"
"\n"
"#if defined(GL_ARB_shader_draw_parameters) && GL_ARB_shader_draw_parameters\n"
"    uint vid = uint(gl_VertexID - gl_BaseVertexARB);\n"
"#else\n"
"    uint vid = uint(gl_VertexID);\n"
"#endif\n"
"\n"
"#if VS_EXPAND == 1 // Point\n"
"\n"
"    vtx = load_vertex(vid >> 2);\n"
"\n"
"    vtx.p.x += ((vid & 1u) != 0u) ? PointSize.x : 0.0f; \n"
"    vtx.p.y += ((vid & 2u) != 0u) ? PointSize.y : 0.0f;\n"
"\n"
"#elif VS_EXPAND == 2 // Line\n"
"\n"
"    uint vid_base = vid >> 2;\n"
"    bool is_bottom = (vid & 2u) != 0u;\n"
"    bool is_right = (vid & 1u) != 0u;\n"
"    uint vid_other = is_bottom ? vid_base - 1 : vid_base + 1;\n"
"    vtx = load_vertex(vid_base);\n"
"    ProcessedVertex other = load_vertex(vid_other);\n"
"\n"
"    vec2 line_vector = normalize(vtx.p.xy - other.p.xy);\n"
"    vec2 line_normal = vec2(line_vector.y, -line_vector.x);\n"
"    vec2 line_width = (line_normal * PointSize) / 2;\n"
"    // line_normal is inverted for bottom point\n"
"    vec2 offset = ((uint(is_bottom) ^ uint(is_right)) != 0u) ? line_width : -line_width;\n"
"    vtx.p.xy += offset;\n"
"\n"
"    // Lines will be run as (0 1 2) (1 2 3)\n"
"    // This means that both triangles will have a point based off the top line point as their first point\n"
"    // So we don't have to do anything for !IIP\n"
"\n"
"#elif VS_EXPAND == 3 // Sprite\n"
"\n"
"    // Sprite points are always in pairs\n"
"    uint vid_base = vid >> 1;\n"
"    uint vid_lt = vid_base & ~1u;\n"
"    uint vid_rb = vid_base | 1u;\n"
"\n"
"    ProcessedVertex lt = load_vertex(vid_lt);\n"
"    ProcessedVertex rb = load_vertex(vid_rb);\n"
"    vtx = rb;\n"
"\n"
"    bool is_right = ((vid & 1u) != 0u);\n"
"    vtx.p.x = is_right ? lt.p.x : vtx.p.x;\n"
"    vtx.t_float.x = is_right ? lt.t_float.x : vtx.t_float.x;\n"
"    vtx.t_int.xz = is_right ? lt.t_int.xz : vtx.t_int.xz;\n"
"\n"
"    bool is_bottom = ((vid & 2u) != 0u);\n"
"    vtx.p.y = is_bottom ? lt.p.y : vtx.p.y;\n"
"    vtx.t_float.y = is_bottom ? lt.t_float.y : vtx.t_float.y;\n"
"    vtx.t_int.yw = is_bottom ? lt.t_int.yw : vtx.t_int.yw;\n"
"\n"
"#endif\n"
"\n"
"    gl_Position = vtx.p;\n"
"    VSout.t_float = vtx.t_float;\n"
"    VSout.t_int = vtx.t_int;\n"
"    VSout.c = vtx.c;\n"
"}\n"
"\n"
"#endif // VS_EXPAND\n"
"\n"
"#endif // VERTEX_SHADER\n"
;
