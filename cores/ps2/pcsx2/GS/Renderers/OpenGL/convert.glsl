static const char convert_glsl_shader_raw[] = 
"#ifdef VERTEX_SHADER\n"
"\n"
"layout(location = 0) in vec2 POSITION;\n"
"layout(location = 1) in vec2 TEXCOORD0;\n"
"layout(location = 7) in vec4 COLOR;\n"
"\n"
"// FIXME set the interpolation (don't know what dx do)\n"
"// flat means that there is no interpolation. The value given to the fragment shader is based on the provoking vertex conventions.\n"
"//\n"
"// noperspective means that there will be linear interpolation in window-space. This is usually not what you want, but it can have its uses.\n"
"//\n"
"// smooth, the default, means to do perspective-correct interpolation.\n"
"//\n"
"// The centroid qualifier only matters when multisampling. If this qualifier is not present, then the value is interpolated to the pixel's center, anywhere in the pixel, or to one of the pixel's samples. This sample may lie outside of the actual primitive being rendered, since a primitive can cover only part of a pixel's area. The centroid qualifier is used to prevent this; the interpolation point must fall within both the pixel's area and the primitive's area.\n"
"out vec4 PSin_p;\n"
"out vec2 PSin_t;\n"
"out vec4 PSin_c;\n"
"\n"
"void vs_main()\n"
"{\n"
"	PSin_p = vec4(POSITION, 0.5f, 1.0f);\n"
"	PSin_t = TEXCOORD0;\n"
"	PSin_c = COLOR;\n"
"	gl_Position = vec4(POSITION, 0.5f, 1.0f); // NOTE I don't know if it is possible to merge POSITION_OUT and gl_Position\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"in vec4 PSin_p;\n"
"in vec2 PSin_t;\n"
"in vec4 PSin_c;\n"
"\n"
"layout(binding = 0) uniform sampler2D TextureSampler;\n"
"\n"
"// Give a different name so I remember there is a special case!\n"
"#if defined(ps_convert_rgba8_16bits) || defined(ps_convert_float32_32bits)\n"
"layout(location = 0) out uint SV_Target1;\n"
"#else\n"
"layout(location = 0) out vec4 SV_Target0;\n"
"#endif\n"
"\n"
"vec4 sample_c()\n"
"{\n"
"	return texture(TextureSampler, PSin_t);\n"
"}\n"
"\n"
"#ifdef ps_copy\n"
"void ps_copy()\n"
"{\n"
"	SV_Target0 = sample_c();\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_depth_copy\n"
"void ps_depth_copy()\n"
"{\n"
"  gl_FragDepth = sample_c().r;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_downsample_copy\n"
"uniform ivec2 ClampMin;\n"
"uniform int DownsampleFactor;\n"
"uniform float Weight;\n"
"\n"
"void ps_downsample_copy()\n"
"{\n"
"	ivec2 coord = max(ivec2(gl_FragCoord.xy) * DownsampleFactor, ClampMin);\n"
"	vec4 result = vec4(0);\n"
"	for (int yoff = 0; yoff < DownsampleFactor; yoff++)\n"
"	{\n"
"		for (int xoff = 0; xoff < DownsampleFactor; xoff++)\n"
"			result += texelFetch(TextureSampler, coord + ivec2(xoff, yoff), 0);\n"
"	}\n"
"	SV_Target0 = result / Weight;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_16bits\n"
"// Need to be careful with precision here, it can break games like Spider-Man 3 and Dogs Life\n"
"void ps_convert_rgba8_16bits()\n"
"{\n"
"	highp uvec4 i = uvec4(sample_c() * vec4(255.5f, 255.5f, 255.5f, 255.5f));\n"
"\n"
"	SV_Target1 = ((i.x & 0x00F8u) >> 3) | ((i.y & 0x00F8u) << 2) | ((i.z & 0x00f8u) << 7) | ((i.w & 0x80u) << 8);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float32_32bits\n"
"void ps_convert_float32_32bits()\n"
"{\n"
"	// Convert a GL_FLOAT32 depth texture into a 32 bits UINT texture\n"
"#if HAS_CLIP_CONTROL\n"
"	SV_Target1 = uint(exp2(32.0f) * sample_c().r);\n"
"#else\n"
"	SV_Target1 = uint(exp2(24.0f) * sample_c().r);\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float32_rgba8\n"
"void ps_convert_float32_rgba8()\n"
"{\n"
"	// Convert a GL_FLOAT32 depth texture into a RGBA color texture\n"
"#if HAS_CLIP_CONTROL\n"
"	uint d = uint(sample_c().r * exp2(32.0f));\n"
"#else\n"
"	uint d = uint(sample_c().r * exp2(24.0f));\n"
"#endif\n"
"	SV_Target0 = vec4(uvec4((d & 0xFFu), ((d >> 8) & 0xFFu), ((d >> 16) & 0xFFu), (d >> 24))) / vec4(255.0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float16_rgb5a1\n"
"void ps_convert_float16_rgb5a1()\n"
"{\n"
"	// Convert a GL_FLOAT32 (only 16 lsb) depth into a RGB5A1 color texture\n"
"#if HAS_CLIP_CONTROL\n"
"	uint d = uint(sample_c().r * exp2(32.0f));\n"
"#else\n"
"	uint d = uint(sample_c().r * exp2(24.0f));\n"
"#endif\n"
"	SV_Target0 = vec4(uvec4(d << 3, d >> 2, d >> 7, d >> 8) & uvec4(0xf8, 0xf8, 0xf8, 0x80)) / 255.0f;\n"
"}\n"
"#endif\n"
"\n"
"float rgba8_to_depth32(vec4 unorm)\n"
"{\n"
"	uvec4 c = uvec4(unorm * vec4(255.5f));\n"
"#if HAS_CLIP_CONTROL\n"
"	return float(c.r | (c.g << 8) | (c.b << 16) | (c.a << 24)) * exp2(-32.0f);\n"
"#else\n"
"	return float(c.r | (c.g << 8) | (c.b << 16) | (c.a << 24)) * exp2(-24.0f);\n"
"#endif\n"
"}\n"
"\n"
"float rgba8_to_depth24(vec4 unorm)\n"
"{\n"
"	uvec3 c = uvec3(unorm.rgb * vec3(255.5f));\n"
"#if HAS_CLIP_CONTROL\n"
"	return float(c.r | (c.g << 8) | (c.b << 16)) * exp2(-32.0f);\n"
"#else\n"
"	return float(c.r | (c.g << 8) | (c.b << 16)) * exp2(-24.0f);\n"
"#endif\n"
"}\n"
"\n"
"float rgba8_to_depth16(vec4 unorm)\n"
"{\n"
"	uvec2 c = uvec2(unorm.rg * vec2(255.5f));\n"
"#if HAS_CLIP_CONTROL\n"
"	return float(c.r | (c.g << 8)) * exp2(-32.0f);\n"
"#else\n"
"	return float(c.r | (c.g << 8)) * exp2(-24.0f);\n"
"#endif\n"
"}\n"
"\n"
"float rgb5a1_to_depth16(vec4 unorm)\n"
"{\n"
"	uvec4 c = uvec4(unorm * vec4(255.5f));\n"
"#if HAS_CLIP_CONTROL\n"
"	return float(((c.r & 0xF8u) >> 3) | ((c.g & 0xF8u) << 2) | ((c.b & 0xF8u) << 7) | ((c.a & 0x80u) << 8)) * exp2(-32.0f);\n"
"#else\n"
"	return float(((c.r & 0xF8u) >> 3) | ((c.g & 0xF8u) << 2) | ((c.b & 0xF8u) << 7) | ((c.a & 0x80u) << 8)) * exp2(-24.0f);\n"
"#endif\n"
"}\n"
"\n"
"#ifdef ps_convert_float32_float24\n"
"void ps_convert_float32_float24()\n"
"{\n"
"	// Truncates depth value to 24bits\n"
"	uint d = uint(sample_c().r * exp2(32.0f)) & 0xFFFFFFu;\n"
"	gl_FragDepth = float(d) * exp2(-32.0f);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float32\n"
"void ps_convert_rgba8_float32()\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth32(sample_c());\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float24\n"
"void ps_convert_rgba8_float24()\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth24(sample_c());\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float16\n"
"void ps_convert_rgba8_float16()\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth16(sample_c());\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgb5a1_float16\n"
"void ps_convert_rgb5a1_float16()\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	gl_FragDepth = rgb5a1_to_depth16(sample_c());\n"
"}\n"
"#endif\n"
"\n"
"#define SAMPLE_RGBA_DEPTH_BILN(CONVERT_FN)"
"	ivec2 dims = textureSize(TextureSampler, 0); "
"	vec2 top_left_f = PSin_t * vec2(dims) - 0.5f; "
"	ivec2 top_left = ivec2(floor(top_left_f)); "
"	ivec4 coords = clamp(ivec4(top_left, top_left + 1), ivec4(0), dims.xyxy - 1); "
"	vec2 mix_vals = fract(top_left_f); "
"	float depthTL = CONVERT_FN(texelFetch(TextureSampler, coords.xy, 0)); "
"	float depthTR = CONVERT_FN(texelFetch(TextureSampler, coords.zy, 0)); "
"	float depthBL = CONVERT_FN(texelFetch(TextureSampler, coords.xw, 0)); "
"	float depthBR = CONVERT_FN(texelFetch(TextureSampler, coords.zw, 0)); "
"	gl_FragDepth = mix(mix(depthTL, depthTR, mix_vals.x), mix(depthBL, depthBR, mix_vals.x), mix_vals.y);\n"
"\n"
"#ifdef ps_convert_rgba8_float32_biln\n"
"void ps_convert_rgba8_float32_biln()\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth32);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float24_biln\n"
"void ps_convert_rgba8_float24_biln()\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth24);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float16_biln\n"
"void ps_convert_rgba8_float16_biln()\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth16);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgb5a1_float16_biln\n"
"void ps_convert_rgb5a1_float16_biln()\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgb5a1_to_depth16);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba_8i\n"
"uniform uint SBW;\n"
"uniform uint DBW;\n"
"uniform float ScaleFactor;\n"
"\n"
"void ps_convert_rgba_8i()\n"
"{\n"
"	// Convert a RGBA texture into a 8 bits packed texture\n"
"	// Input column: 8x2 RGBA pixels\n"
"	// 0: 8 RGBA\n"
"	// 1: 8 RGBA\n"
"	// Output column: 16x4 Index pixels\n"
"	// 0: 8 R | 8 B\n"
"	// 1: 8 R | 8 B\n"
"	// 2: 8 G | 8 A\n"
"	// 3: 8 G | 8 A\n"
"	uvec2 pos = uvec2(gl_FragCoord.xy);\n"
"\n"
"	// Collapse separate R G B A areas into their base pixel\n"
"	uvec2 block = (pos & ~uvec2(15u, 3u)) >> 1;\n"
"	uvec2 subblock = pos & uvec2(7u, 1u);\n"
"	uvec2 coord = block | subblock;\n"
"\n"
"	// Compensate for potentially differing page pitch.\n"
"	uvec2 block_xy = coord / uvec2(64u, 32u);\n"
"	uint block_num = (block_xy.y * (DBW / 128u)) + block_xy.x;\n"
"	uvec2 block_offset = uvec2((block_num % (SBW / 64u)) * 64u, (block_num / (SBW / 64u)) * 32u);\n"
"	coord = (coord % uvec2(64u, 32u)) + block_offset;\n"
"\n"
"	// Apply offset to cols 1 and 2\n"
"	uint is_col23 = pos.y & 4u;\n"
"	uint is_col13 = pos.y & 2u;\n"
"	uint is_col12 = is_col23 ^ (is_col13 << 1);\n"
"	coord.x ^= is_col12; // If cols 1 or 2, flip bit 3 of x\n"
"\n"
"	if (floor(ScaleFactor) != ScaleFactor)\n"
"		coord = uvec2(vec2(coord) * ScaleFactor);\n"
"	else\n"
"		coord *= uvec2(ScaleFactor);\n"
"\n"
"	vec4 pixel = texelFetch(TextureSampler, ivec2(coord), 0);\n"
"	vec2  sel0 = (pos.y & 2u) == 0u ? pixel.rb : pixel.ga;\n"
"	float sel1 = (pos.x & 8u) == 0u ? sel0.x : sel0.y;\n"
"	SV_Target0 = vec4(sel1);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_filter_transparency\n"
"void ps_filter_transparency()\n"
"{\n"
"	vec4 c = sample_c();\n"
"	SV_Target0 = vec4(c.rgb, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"// Used for DATE (stencil)\n"
"// DATM == 1\n"
"#ifdef ps_datm1\n"
"void ps_datm1()\n"
"{\n"
"	if(sample_c().a < (127.5f / 255.0f)) // >= 0x80 pass\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"// Used for DATE (stencil)\n"
"// DATM == 0\n"
"#ifdef ps_datm0\n"
"void ps_datm0()\n"
"{\n"
"	if((127.5f / 255.0f) < sample_c().a) // < 0x80 pass (== 0x80 should not pass)\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"// Used for DATE (stencil)\n"
"// DATM == 1\n"
"#ifdef ps_datm1_rta_correction\n"
"void ps_datm1_rta_correction()\n"
"{\n"
"	if(sample_c().a < (254.5f / 255.0f)) // >= 0x80 pass\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"// Used for DATE (stencil)\n"
"// DATM == 0\n"
"#ifdef ps_datm0_rta_correction\n"
"void ps_datm0_rta_correction()\n"
"{\n"
"	if((254.5f / 255.0f) < sample_c().a) // < 0x80 pass (== 0x80 should not pass)\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_rta_correction\n"
"void ps_rta_correction()\n"
"{\n"
"	vec4 value = sample_c();\n"
"	SV_Target0 = vec4(value.rgb, value.a / (128.25f / 255.0f));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_rta_decorrection\n"
"void ps_rta_decorrection()\n"
"{\n"
"	vec4 value = sample_c();\n"
"	SV_Target0 = vec4(value.rgb, value.a * (128.25f / 255.0f));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_hdr_init\n"
"void ps_hdr_init()\n"
"{\n"
"	vec4 value = sample_c();\n"
"	SV_Target0 = vec4(round(value.rgb * 255.0f) / 65535.0f, value.a);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_hdr_resolve\n"
"void ps_hdr_resolve()\n"
"{\n"
"	vec4 value = sample_c();\n"
"	SV_Target0 = vec4(vec3(uvec3(value.rgb * 65535.0f) & 255u) / 255.0f, value.a);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_clut_4\n"
"uniform uvec3 offset;\n"
"uniform float scale;\n"
"\n"
"void ps_convert_clut_4()\n"
"{\n"
"	// CLUT4 is easy, just two rows of 8x8.\n"
"	uint index = uint(gl_FragCoord.x) + offset.z;\n"
"	uvec2 pos = uvec2(index % 8u, index / 8u);\n"
"\n"
"	ivec2 final = ivec2(floor(vec2(offset.xy + pos) * vec2(scale)));\n"
"	SV_Target0 = texelFetch(TextureSampler, final, 0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_clut_8\n"
"uniform uvec3 offset;\n"
"uniform float scale;\n"
"\n"
"void ps_convert_clut_8()\n"
"{\n"
"	uint index = min(uint(gl_FragCoord.x) + offset.z, 255u);\n"
"\n"
"	// CLUT is arranged into 8 groups of 16x2, with the top-right and bottom-left quadrants swapped.\n"
"	// This can probably be done better..\n"
"	uint subgroup = (index / 8u) % 4u;\n"
"	uvec2 pos;\n"
"	pos.x = (index % 8u) + ((subgroup >= 2u) ? 8u : 0u);\n"
"	pos.y = ((index / 32u) * 2u) + (subgroup % 2u);\n"
"\n"
"	ivec2 final = ivec2(floor(vec2(offset.xy + pos) * vec2(scale)));\n"
"	SV_Target0 = texelFetch(TextureSampler, final, 0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_yuv\n"
"uniform ivec2 EMOD;\n"
"\n"
"void ps_yuv()\n"
"{\n"
"	vec4 i = sample_c();\n"
"	vec4 o = vec4(0.0f);\n"
"\n"
"	mat3 rgb2yuv; // Value from GS manual\n"
"	rgb2yuv[0] = vec3(0.587, -0.311, -0.419);\n"
"	rgb2yuv[1] = vec3(0.114, 0.500, -0.081);\n"
"	rgb2yuv[2] = vec3(0.299, -0.169, 0.500);\n"
"\n"
"	vec3 yuv = rgb2yuv * i.gbr;\n"
"\n"
"	float Y = float(0xDB)/255.0f * yuv.x + float(0x10)/255.0f;\n"
"	float Cr = float(0xE0)/255.0f * yuv.y + float(0x80)/255.0f;\n"
"	float Cb = float(0xE0)/255.0f * yuv.z + float(0x80)/255.0f;\n"
"\n"
"	switch(EMOD.x)\n"
"	{\n"
"		case 0:\n"
"			o.a = i.a;\n"
"			break;\n"
"		case 1:\n"
"			o.a = Y;\n"
"			break;\n"
"		case 2:\n"
"			o.a = Y/2.0f;\n"
"			break;\n"
"		case 3:\n"
"			o.a = 0.0f;\n"
"			break;\n"
"	}\n"
"\n"
"	switch(EMOD.y)\n"
"	{\n"
"		case 0:\n"
"			o.rgb = i.rgb;\n"
"			break;\n"
"		case 1:\n"
"			o.rgb = vec3(Y);\n"
"			break;\n"
"		case 2:\n"
"			o.rgb = vec3(Y, Cb, Cr);\n"
"			break;\n"
"		case 3:\n"
"			o.rgb = vec3(i.a);\n"
"			break;\n"
"	}\n"
"\n"
"	SV_Target0 = o;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(ps_stencil_image_init_0) || defined(ps_stencil_image_init_1) || defined(ps_stencil_image_init_2) || defined(ps_stencil_image_init_3)\n"
"\n"
"void main()\n"
"{\n"
"	SV_Target0 = vec4(0x7FFFFFFF);\n"
"\n"
"	#ifdef ps_stencil_image_init_0\n"
"		if((127.5f / 255.0f) < sample_c().a) // < 0x80 pass (== 0x80 should not pass)\n"
"			SV_Target0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_1\n"
"		if(sample_c().a < (127.5f / 255.0f)) // >= 0x80 pass\n"
"			SV_Target0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_2\n"
"		if((254.5f / 255.0f) < sample_c().a) // < 0x80 pass (== 0x80 should not pass)\n"
"			SV_Target0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_3\n"
"		if(sample_c().a < (254.5f / 255.0f)) // >= 0x80 pass\n"
"			SV_Target0 = vec4(-1);\n"
"	#endif\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
;
