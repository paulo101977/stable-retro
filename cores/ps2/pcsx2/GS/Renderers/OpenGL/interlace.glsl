static const char interlace_glsl_shader_raw[] = 
"#ifdef FRAGMENT_SHADER\n"
"\n"
"in vec4 PSin_p;\n"
"in vec2 PSin_t;\n"
"in vec4 PSin_c;\n"
"\n"
"uniform vec4 ZrH;\n"
"\n"
"layout(binding = 0) uniform sampler2D TextureSampler;\n"
"\n"
"layout(location = 0) out vec4 SV_Target0;\n"
"\n"
"\n"
"// Weave shader\n"
"void ps_main0()\n"
"{\n"
"	int idx   = int(ZrH.x);          // buffer index passed from CPU\n"
"	int field = idx & 1;             // current field\n"
"	int vpos  = int(gl_FragCoord.y); // vertical position of destination texture\n"
"\n"
"	if ((vpos & 1) == field)\n"
"		SV_Target0 = textureLod(TextureSampler, PSin_t, 0);\n"
"	else\n"
"		discard;\n"
"}\n"
"\n"
"\n"
"// Bob shader\n"
"void ps_main1()\n"
"{\n"
"	SV_Target0 = textureLod(TextureSampler, PSin_t, 0);\n"
"}\n"
"\n"
"\n"
"// Blend shader\n"
"void ps_main2()\n"
"{\n"
"	vec2 vstep = vec2(0.0f, ZrH.y);\n"
"	vec4 c0 = textureLod(TextureSampler, PSin_t - vstep, 0);\n"
"	vec4 c1 = textureLod(TextureSampler, PSin_t, 0);\n"
"	vec4 c2 = textureLod(TextureSampler, PSin_t + vstep, 0);\n"
"\n"
"	SV_Target0 = (c0 + c1 * 2.0f + c2) / 4.0f;\n"
"}\n"
"\n"
"\n"
"// MAD shader - buffering\n"
"void ps_main3()\n"
"{\n"
"	// We take half the lines from the current frame and stores them in the MAD frame buffer.\n"
"	// the MAD frame buffer is split in 2 consecutive banks of 2 fields each, the fields in each bank\n"
"	// are interleaved (top field at even lines and bottom field at odd lines).\n"
"	// When the source texture has an odd vres, the first line of bank 1 would be an odd index\n"
"	// causing the wrong lines to be discarded, so a vertical offset (lofs) is added to the vertical\n"
"	// position of the destination texture to force the proper field alignment\n"
"\n"
"	int  idx    = int(ZrH.x);                                // buffer index passed from CPU\n"
"	int  bank   = idx >> 1;                                  // current bank\n"
"	int  field  = idx & 1;                                   // current field\n"
"	int  vres   = int(ZrH.z) >> 1;                           // vertical resolution of source texture\n"
"	int  lofs   = ((((vres + 1) >> 1) << 1) - vres) & bank;  // line alignment offset for bank 1\n"
"	int  vpos   = int(gl_FragCoord.y) + lofs;                // vertical position of destination texture\n"
"\n"
"	// if the index of current destination line belongs to the current fiels we update it, otherwise\n"
"	// we leave the old line in the destination buffer\n"
"	if ((vpos & 1) == field)\n"
"		SV_Target0 = textureLod(TextureSampler, PSin_t, 0);\n"
"	else\n"
"		discard;\n"
"}\n"
"\n"
"\n"
"// MAD shader - reconstruction\n"
"void ps_main4()\n"
"{\n"
"	// we use the contents of the MAD frame buffer to reconstruct the missing lines from the current field.\n"
"\n"
"	int   idx          = int(ZrH.x);                         // buffer index passed from CPU\n"
"	int   field        = idx & 1;                            // current field\n"
"	int   vpos         = int(gl_FragCoord.y);                // vertical position of destination texture\n"
"	float sensitivity  = ZrH.w;                              // passed from CPU, higher values mean more likely to use weave\n"
"	vec3  motion_thr   = vec3(1.0, 1.0, 1.0) * sensitivity;  //\n"
"	vec2  bofs         = vec2(0.0f, 0.5f);                   // position of the bank 1 relative to source texture size\n"
"	vec2  vscale       = vec2(1.0f, 0.5f);                   // scaling factor from source to destination texture\n"
"	vec2  lofs         = vec2(0.0f, ZrH.y) * vscale;         // distance between two adjacent lines relative to source texture size\n"
"	vec2  iptr         = PSin_t * vscale;                    // pointer to the current pixel in the source texture\n"
"\n"
"	vec2 p_t0; // pointer to current pixel (missing or not) from most recent frame\n"
"	vec2 p_t1; // pointer to current pixel (missing or not) from one frame back\n"
"	vec2 p_t2; // pointer to current pixel (missing or not) from two frames back\n"
"	vec2 p_t3; // pointer to current pixel (missing or not) from three frames back\n"
"\n"
"	switch (idx)\n"
"	{\n"
"		case 1:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 2:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 3:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"		default:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"	}\n"
"\n"
"\n"
"	// calculating motion, only relevant for missing lines where the center line is pointed\n"
"	// by p_t1\n"
"\n"
"	vec4 hn = textureLod(TextureSampler, p_t0 - lofs, 0); // new high pixel\n"
"	vec4 cn = textureLod(TextureSampler, p_t1, 0);        // new center pixel\n"
"	vec4 ln = textureLod(TextureSampler, p_t0 + lofs, 0); // new low pixel\n"
"\n"
"	vec4 ho = textureLod(TextureSampler, p_t2 - lofs, 0); // old high pixel\n"
"	vec4 co = textureLod(TextureSampler, p_t3, 0);        // old center pixel\n"
"	vec4 lo = textureLod(TextureSampler, p_t2 + lofs, 0); // old low pixel\n"
"\n"
"	vec3 mh = hn.rgb - ho.rgb; // high pixel motion\n"
"	vec3 mc = cn.rgb - co.rgb; // center pixel motion\n"
"	vec3 ml = ln.rgb - lo.rgb; // low pixel motion\n"
"\n"
"	mh = max(mh, -mh) - motion_thr;\n"
"	mc = max(mc, -mc) - motion_thr;\n"
"	ml = max(ml, -ml) - motion_thr;\n"
"\n"
"	#if 1 // use this code to evaluate each color motion separately\n"
"		float mh_max = max(max(mh.x, mh.y), mh.z);\n"
"		float mc_max = max(max(mc.x, mc.y), mc.z);\n"
"		float ml_max = max(max(ml.x, ml.y), ml.z);\n"
"	#else // use this code to evaluate average color motion\n"
"		float mh_max = mh.x + mh.y + mh.z;\n"
"		float mc_max = mc.x + mc.y + mc.z;\n"
"		float ml_max = ml.x + ml.y + ml.z;\n"
"	#endif\n"
"\n"
"\n"
"	// selecting deinterlacing output\n"
"\n"
"	if ((vpos & 1) == field)\n"
"	{\n"
"		// output coordinate present on current field\n"
"		SV_Target0 = textureLod(TextureSampler, p_t0, 0);\n"
"	}\n"
"	else if ((iptr.y > 0.5f - lofs.y) || (iptr.y < 0.0 + lofs.y))\n"
"	{\n"
"		// top and bottom lines are always weaved\n"
"		SV_Target0 = cn;\n"
"	}\n"
"	else\n"
"	{\n"
"		// missing line needs to be reconstructed\n"
"		if(((mh_max > 0.0f) || (ml_max > 0.0f)) || (mc_max > 0.0f))\n"
"			// high motion -> interpolate pixels above and below\n"
"			SV_Target0 = (hn + ln) / 2.0f;\n"
"		else\n"
"			// low motion -> weave\n"
"			SV_Target0 = cn;\n"
"	}\n"
"}\n"
"\n"
"#endif\n"
;
