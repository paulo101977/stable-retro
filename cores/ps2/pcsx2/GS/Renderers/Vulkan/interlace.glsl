static const char interlace_glsl_shader_raw[] = 
"#ifdef VERTEX_SHADER\n"
"\n"
"layout(location = 0) in vec4 a_pos;\n"
"layout(location = 1) in vec2 a_tex;\n"
"\n"
"layout(location = 0) out vec2 v_tex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(a_pos.x, -a_pos.y, a_pos.z, a_pos.w);\n"
"	v_tex = a_tex;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"layout(location = 0) in vec2 v_tex;\n"
"layout(location = 0) out vec4 o_col0;\n"
"\n"
"layout(push_constant) uniform cb0\n"
"{\n"
"	vec4 ZrH;\n"
"};\n"
"\n"
"layout(set = 0, binding = 0) uniform sampler2D samp0;\n"
"\n"
"\n"
"// Weave shader\n"
"#ifdef ps_main0\n"
"void ps_main0()\n"
"{\n"
"	const int idx   = int(ZrH.x);          // buffer index passed from CPU\n"
"	const int field = idx & 1;             // current field\n"
"	const int vpos  = int(gl_FragCoord.y); // vertical position of destination texture\n"
"\n"
"	if ((vpos & 1) == field)\n"
"		o_col0 = textureLod(samp0, v_tex, 0);\n"
"	else\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// Bob shader\n"
"#ifdef ps_main1\n"
"void ps_main1()\n"
"{\n"
"	o_col0 = textureLod(samp0, v_tex, 0);\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// Blend shader\n"
"#ifdef ps_main2\n"
"void ps_main2()\n"
"{\n"
"	vec2 vstep = vec2(0.0f, ZrH.y);\n"
"	vec4 c0 = textureLod(samp0, v_tex - vstep, 0);\n"
"	vec4 c1 = textureLod(samp0, v_tex, 0);\n"
"	vec4 c2 = textureLod(samp0, v_tex + vstep, 0);\n"
"\n"
"	o_col0 = (c0 + c1 * 2.0f + c2) / 4.0f;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// MAD shader - buffering\n"
"#ifdef ps_main3\n"
"void ps_main3()\n"
"{\n"
"	// We take half the lines from the current frame and stores them in the MAD frame buffer.\n"
"	// the MAD frame buffer is split in 2 consecutive banks of 2 fields each, the fields in each bank\n"
"	// are interleaved (top field at even lines and bottom field at odd lines).\n"
"	// When the source texture has an odd vres, the first line of bank 1 would be an odd index\n"
"	// causing the wrong lines to be discarded, so a vertical offset (lofs) is added to the vertical\n"
"	// position of the destination texture to force the proper field alignment\n"
"\n"
"	const int  idx    = int(ZrH.x);                               // buffer index passed from CPU\n"
"	const int  bank   = idx >> 1;                                 // current bank\n"
"	const int  field  = idx & 1;                                  // current field\n"
"	const int  vres   = int(ZrH.z) >> 1;                          // vertical resolution of source texture\n"
"	const int  lofs   = ((((vres + 1) >> 1) << 1) - vres) & bank; // line alignment offset for bank 1\n"
"	const int  vpos   = int(gl_FragCoord.y) + lofs;               // vertical position of destination texture\n"
"\n"
"	// if the index of current destination line belongs to the current fiels we update it, otherwise\n"
"	// we leave the old line in the destination buffer\n"
"	if ((vpos & 1) == field)\n"
"		o_col0 = textureLod(samp0, v_tex, 0);\n"
"	else\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// MAD shader - reconstruction\n"
"#ifdef ps_main4\n"
"void ps_main4()\n"
"{\n"
"	// we use the contents of the MAD frame buffer to reconstruct the missing lines from the current\n"
"	// field.\n"
"\n"
"	const int   idx          = int(ZrH.x);                         // buffer index passed from CPU\n"
"	const int   bank         = idx >> 1;                           // current bank\n"
"	const int   field        = idx & 1;                            // current field\n"
"	const int   vpos         = int(gl_FragCoord.y);                // vertical position of destination texture\n"
"	const float sensitivity  = ZrH.w;                              // passed from CPU, higher values mean more likely to use weave\n"
"	const vec3  motion_thr   = vec3(1.0, 1.0, 1.0) * sensitivity;  //\n"
"	const vec2  bofs         = vec2(0.0f, 0.5f);                   // position of the bank 1 relative to source texture size\n"
"	const vec2  vscale       = vec2(1.0f, 0.5f);                   // scaling factor from source to destination texture\n"
"	const vec2  lofs         = vec2(0.0f, ZrH.y) * vscale;         // distance between two adjacent lines relative to source texture size\n"
"	const vec2  iptr         = v_tex * vscale;                     // pointer to the current pixel in the source texture\n"
"\n"
"	vec2 p_t0; // pointer to current pixel (missing or not) from most recent frame\n"
"	vec2 p_t1; // pointer to current pixel (missing or not) from one frame back\n"
"	vec2 p_t2; // pointer to current pixel (missing or not) from two frames back\n"
"	vec2 p_t3; // pointer to current pixel (missing or not) from three frames back\n"
"\n"
"	switch (idx)\n"
"	{\n"
"		case 1:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 2:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr + bofs;\n"
"			break;\n"
"		case 3:\n"
"			p_t0 = iptr + bofs;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"		default:\n"
"			p_t0 = iptr;\n"
"			p_t1 = iptr + bofs;\n"
"			p_t2 = iptr + bofs;\n"
"			p_t3 = iptr;\n"
"			break;\n"
"	}\n"
"\n"
"	// calculating motion, only relevant for missing lines where the \"center line\" is pointed by p_t1\n"
"\n"
"	vec4 hn = textureLod(samp0, p_t0 - lofs, 0); // new high pixel\n"
"	vec4 cn = textureLod(samp0, p_t1, 0);        // new center pixel\n"
"	vec4 ln = textureLod(samp0, p_t0 + lofs, 0); // new low pixel\n"
"\n"
"	vec4 ho = textureLod(samp0, p_t2 - lofs, 0); // old high pixel\n"
"	vec4 co = textureLod(samp0, p_t3, 0);        // old center pixel\n"
"	vec4 lo = textureLod(samp0, p_t2 + lofs, 0); // old low pixel\n"
"\n"
"	vec3 mh = hn.rgb - ho.rgb; // high pixel motion\n"
"	vec3 mc = cn.rgb - co.rgb; // center pixel motion\n"
"	vec3 ml = ln.rgb - lo.rgb; // low pixel motion\n"
"\n"
"	mh = max(mh, -mh) - motion_thr;\n"
"	mc = max(mc, -mc) - motion_thr;\n"
"	ml = max(ml, -ml) - motion_thr;\n"
"\n"
"	#if 1 // use this code to evaluate each color motion separately\n"
"		float mh_max = max(max(mh.x, mh.y), mh.z);\n"
"		float mc_max = max(max(mc.x, mc.y), mc.z);\n"
"		float ml_max = max(max(ml.x, ml.y), ml.z);\n"
"	#else // use this code to evaluate average color motion\n"
"		float mh_max = mh.x + mh.y + mh.z;\n"
"		float mc_max = mc.x + mc.y + mc.z;\n"
"		float ml_max = ml.x + ml.y + ml.z;\n"
"	#endif\n"
"\n"
"	// selecting deinterlacing output\n"
"\n"
"	if ((vpos & 1) == field) // output coordinate present on current field\n"
"	{\n"
"		// output coordinate present on current field\n"
"		o_col0 = textureLod(samp0, p_t0, 0);\n"
"	}\n"
"	else if ((iptr.y > 0.5f - lofs.y) || (iptr.y < 0.0 + lofs.y))\n"
"	{\n"
"		// top and bottom lines are always weaved\n"
"		o_col0 = cn;\n"
"	}\n"
"	else\n"
"	{\n"
"		// missing line needs to be reconstructed\n"
"		if(((mh_max > 0.0f) || (ml_max > 0.0f)) || (mc_max > 0.0f))\n"
"			// high motion -> interpolate pixels above and below\n"
"			o_col0 = (hn + ln) / 2.0f;\n"
"		else\n"
"			// low motion -> weave\n"
"			o_col0 = cn;\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
;
