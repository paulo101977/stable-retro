static const char tfx_glsl_shader_raw[] = 
"#if defined(VERTEX_SHADER)\n"
"\n"
"layout(std140, set = 0, binding = 0) uniform cb0\n"
"{\n"
"	vec2 VertexScale;\n"
"	vec2 VertexOffset;\n"
"	vec2 TextureScale;\n"
"	vec2 TextureOffset;\n"
"	vec2 PointSize;\n"
"	uint MaxDepth;\n"
"	uint pad_cb0;\n"
"};\n"
"\n"
"layout(location = 0) out VSOutput\n"
"{\n"
"	vec4 t;\n"
"	vec4 ti;\n"
"\n"
"	#if VS_IIP != 0\n"
"		vec4 c;\n"
"	#else\n"
"		flat vec4 c;\n"
"	#endif\n"
"} vsOut;\n"
"\n"
"#if VS_EXPAND == 0\n"
"\n"
"layout(location = 0) in vec2 a_st;\n"
"layout(location = 1) in uvec4 a_c;\n"
"layout(location = 2) in float a_q;\n"
"layout(location = 3) in uvec2 a_p;\n"
"layout(location = 4) in uint a_z;\n"
"layout(location = 5) in uvec2 a_uv;\n"
"layout(location = 6) in vec4 a_f;\n"
"\n"
"void main()\n"
"{\n"
"	// Clamp to max depth, gs doesn't wrap\n"
"	uint z = min(a_z, MaxDepth);\n"
"\n"
"	// pos -= 0.05 (1/320 pixel) helps avoiding rounding problems (integral part of pos is usually 5 digits, 0.05 is about as low as we can go)\n"
"	// example: ceil(afterseveralvertextransformations(y = 133)) => 134 => line 133 stays empty\n"
"	// input granularity is 1/16 pixel, anything smaller than that won't step drawing up/left by one pixel\n"
"	// example: 133.0625 (133 + 1/16) should start from line 134, ceil(133.0625 - 0.05) still above 133\n"
"\n"
"	gl_Position = vec4(a_p, float(z), 1.0f) - vec4(0.05f, 0.05f, 0, 0);\n"
"	gl_Position.xy = gl_Position.xy * vec2(VertexScale.x, -VertexScale.y) - vec2(VertexOffset.x, -VertexOffset.y);\n"
"	gl_Position.z *= exp2(-32.0f);		// integer->float depth\n"
"	gl_Position.y = -gl_Position.y;\n"
"\n"
"	#if VS_TME\n"
"		vec2 uv = a_uv - TextureOffset;\n"
"		vec2 st = a_st - TextureOffset;\n"
"\n"
"		// Integer nomalized\n"
"		vsOut.ti.xy = uv * TextureScale;\n"
"\n"
"		#if VS_FST\n"
"			// Integer integral\n"
"			vsOut.ti.zw = uv;\n"
"		#else\n"
"			// float for post-processing in some games\n"
"			vsOut.ti.zw = st / TextureScale;\n"
"		#endif\n"
"\n"
"		// Float coords\n"
"		vsOut.t.xy = st;\n"
"		vsOut.t.w = a_q;\n"
"	#else\n"
"		vsOut.t = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
"		vsOut.ti = vec4(0.0f);\n"
"	#endif\n"
"\n"
"	#if VS_POINT_SIZE\n"
"		gl_PointSize = PointSize.x;\n"
"	#endif\n"
"\n"
"	vsOut.c = vec4(a_c);\n"
"	vsOut.t.z = a_f.r;\n"
"}\n"
"\n"
"#else // VS_EXPAND\n"
"\n"
"struct RawVertex\n"
"{\n"
"	vec2 ST;\n"
"	uint RGBA;\n"
"	float Q;\n"
"	uint XY;\n"
"	uint Z;\n"
"	uint UV;\n"
"	uint FOG;\n"
"};\n"
"\n"
"layout(std140, set = 0, binding = 2) readonly buffer VertexBuffer {\n"
"	RawVertex vertex_buffer[];\n"
"};\n"
"\n"
"struct ProcessedVertex\n"
"{\n"
"	vec4 p;\n"
"	vec4 t;\n"
"	vec4 ti;\n"
"	vec4 c;\n"
"};\n"
"\n"
"ProcessedVertex load_vertex(uint index)\n"
"{\n"
"	RawVertex rvtx = vertex_buffer[gl_BaseVertexARB + index];\n"
"\n"
"	vec2 a_st = rvtx.ST;\n"
"	uvec4 a_c = uvec4(bitfieldExtract(rvtx.RGBA, 0, 8), bitfieldExtract(rvtx.RGBA, 8, 8),\n"
"	                  bitfieldExtract(rvtx.RGBA, 16, 8), bitfieldExtract(rvtx.RGBA, 24, 8));\n"
"	float a_q = rvtx.Q;\n"
"	uvec2 a_p = uvec2(bitfieldExtract(rvtx.XY, 0, 16), bitfieldExtract(rvtx.XY, 16, 16));\n"
"	uint a_z = rvtx.Z;\n"
"	uvec2 a_uv = uvec2(bitfieldExtract(rvtx.UV, 0, 16), bitfieldExtract(rvtx.UV, 16, 16));\n"
"	vec4 a_f = unpackUnorm4x8(rvtx.FOG);\n"
"\n"
"	ProcessedVertex vtx;\n"
"\n"
"	uint z = min(a_z, MaxDepth);\n"
"	vtx.p = vec4(a_p, float(z), 1.0f) - vec4(0.05f, 0.05f, 0, 0);\n"
"	vtx.p.xy = vtx.p.xy * vec2(VertexScale.x, -VertexScale.y) - vec2(VertexOffset.x, -VertexOffset.y);\n"
"	vtx.p.z *= exp2(-32.0f);		// integer->float depth\n"
"	vtx.p.y = -vtx.p.y;\n"
"\n"
"	#if VS_TME\n"
"		vec2 uv = a_uv - TextureOffset;\n"
"		vec2 st = a_st - TextureOffset;\n"
"		vtx.ti.xy = uv * TextureScale;\n"
"\n"
"		#if VS_FST\n"
"			vtx.ti.zw = uv;\n"
"		#else\n"
"			vtx.ti.zw = st / TextureScale;\n"
"		#endif\n"
"\n"
"		vtx.t.xy = st;\n"
"		vtx.t.w = a_q;\n"
"	#else\n"
"		vtx.t = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
"		vtx.ti = vec4(0.0f);\n"
"	#endif\n"
"\n"
"	vtx.c = a_c;\n"
"	vtx.t.z = a_f.r;\n"
"\n"
"	return vtx;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	ProcessedVertex vtx;\n"
"	uint vid = uint(gl_VertexIndex - gl_BaseVertexARB);\n"
"\n"
"#if VS_EXPAND == 1 // Point\n"
"\n"
"	vtx = load_vertex(vid >> 2);\n"
"\n"
"	vtx.p.x += ((vid & 1u) != 0u) ? PointSize.x : 0.0f; \n"
"	vtx.p.y += ((vid & 2u) != 0u) ? PointSize.y : 0.0f;\n"
"\n"
"#elif VS_EXPAND == 2 // Line\n"
"\n"
"	uint vid_base = vid >> 2;\n"
"\n"
"	bool is_bottom = (vid & 2u) != 0u;\n"
"	bool is_right = (vid & 1u) != 0u;\n"
"#ifdef VS_PROVOKING_VERTEX_LAST\n"
"	uint vid_other = is_bottom ? vid_base - 1 : vid_base + 1;\n"
"#else\n"
"	uint vid_other = is_bottom ? vid_base + 1 : vid_base - 1;\n"
"#endif\n"
"	\n"
"	vtx = load_vertex(vid_base);\n"
"	ProcessedVertex other = load_vertex(vid_other);\n"
"\n"
"	vec2 line_vector = normalize(vtx.p.xy - other.p.xy);\n"
"	vec2 line_normal = vec2(line_vector.y, -line_vector.x);\n"
"	vec2 line_width = (line_normal * PointSize) / 2;\n"
"	// line_normal is inverted for bottom point\n"
"	vec2 offset = ((uint(is_bottom) ^ uint(is_right)) != 0u) ? line_width : -line_width;\n"
"	vtx.p.xy += offset;\n"
"\n"
"	// Lines will be run as (0 1 2) (1 2 3)\n"
"	// This means that both triangles will have a point based off the top line point as their first point\n"
"	// So we don't have to do anything for !IIP\n"
"\n"
"#elif VS_EXPAND == 3 // Sprite\n"
"\n"
"	// Sprite points are always in pairs\n"
"	uint vid_base = vid >> 1;\n"
"	uint vid_lt = vid_base & ~1u;\n"
"	uint vid_rb = vid_base | 1u;\n"
"\n"
"	ProcessedVertex lt = load_vertex(vid_lt);\n"
"	ProcessedVertex rb = load_vertex(vid_rb);\n"
"	vtx = rb;\n"
"\n"
"	bool is_right = ((vid & 1u) != 0u);\n"
"	vtx.p.x = is_right ? lt.p.x : vtx.p.x;\n"
"	vtx.t.x = is_right ? lt.t.x : vtx.t.x;\n"
"	vtx.ti.xz = is_right ? lt.ti.xz : vtx.ti.xz;\n"
"\n"
"	bool is_bottom = ((vid & 2u) != 0u);\n"
"	vtx.p.y = is_bottom ? lt.p.y : vtx.p.y;\n"
"	vtx.t.y = is_bottom ? lt.t.y : vtx.t.y;\n"
"	vtx.ti.yw = is_bottom ? lt.ti.yw : vtx.ti.yw;\n"
"\n"
"#endif\n"
"\n"
"	gl_Position = vtx.p;\n"
"	vsOut.t = vtx.t;\n"
"	vsOut.ti = vtx.ti;\n"
"	vsOut.c = vtx.c;\n"
"}\n"
"\n"
"#endif // VS_EXPAND\n"
"\n"
"#endif // VERTEX_SHADER\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"#define FMT_32 0\n"
"#define FMT_24 1\n"
"#define FMT_16 2\n"
"\n"
"#define SHUFFLE_READ  1\n"
"#define SHUFFLE_WRITE 2\n"
"#define SHUFFLE_READWRITE 3\n"
"\n"
"#ifndef VS_TME\n"
"#define VS_TME 1\n"
"#define VS_FST 1\n"
"#endif\n"
"\n"
"#ifndef GS_IIP\n"
"#define GS_IIP 0\n"
"#define GS_PRIM 3\n"
"#define GS_POINT 0\n"
"#define GS_LINE 0\n"
"#endif\n"
"\n"
"#ifndef PS_FST\n"
"#define PS_FST 0\n"
"#define PS_WMS 0\n"
"#define PS_WMT 0\n"
"#define PS_ADJS 0\n"
"#define PS_ADJT 0\n"
"#define PS_FMT FMT_32\n"
"#define PS_AEM 0\n"
"#define PS_TFX 0\n"
"#define PS_TCC 1\n"
"#define PS_ATST 1\n"
"#define PS_AFAIL 0\n"
"#define PS_FOG 0\n"
"#define PS_BLEND_HW 0\n"
"#define PS_A_MASKED 0\n"
"#define PS_FBA 0\n"
"#define PS_FBMASK 0\n"
"#define PS_LTF 1\n"
"#define PS_TCOFFSETHACK 0\n"
"#define PS_SHUFFLE 0\n"
"#define PS_SHUFFLE_SAME 0\n"
"#define PS_PROCESS_BA 0\n"
"#define PS_PROCESS_RG 0\n"
"#define PS_SHUFFLE_ACROSS 0\n"
"#define PS_WRITE_RG 0\n"
"#define PS_READ16_SRC 0\n"
"#define PS_DST_FMT 0\n"
"#define PS_DEPTH_FMT 0\n"
"#define PS_PAL_FMT 0\n"
"#define PS_CHANNEL_FETCH 0\n"
"#define PS_TALES_OF_ABYSS_HLE 0\n"
"#define PS_URBAN_CHAOS_HLE 0\n"
"#define PS_HDR 0\n"
"#define PS_COLCLIP 0\n"
"#define PS_BLEND_A 0\n"
"#define PS_BLEND_B 0\n"
"#define PS_BLEND_C 0\n"
"#define PS_BLEND_D 0\n"
"#define PS_FIXED_ONE_A 0\n"
"#define PS_PABE 0\n"
"#define PS_DITHER 0\n"
"#define PS_DITHER_ADJUST 0\n"
"#define PS_ZCLAMP 0\n"
"#define PS_FEEDBACK_LOOP 0\n"
"#define PS_TEX_IS_FB 0\n"
"#endif\n"
"\n"
"#define SW_BLEND (PS_BLEND_A || PS_BLEND_B || PS_BLEND_D)\n"
"#define SW_BLEND_NEEDS_RT (SW_BLEND && (PS_BLEND_A == 1 || PS_BLEND_B == 1 || PS_BLEND_C == 1 || PS_BLEND_D == 1))\n"
"#define SW_AD_TO_HW (PS_BLEND_C == 1 && PS_A_MASKED)\n"
"\n"
"#define PS_FEEDBACK_LOOP_IS_NEEDED (PS_TEX_IS_FB == 1 || PS_FBMASK || SW_BLEND_NEEDS_RT || SW_AD_TO_HW || (PS_DATE >= 5))\n"
"\n"
"#define NEEDS_TEX (PS_TFX != 4)\n"
"\n"
"layout(std140, set = 0, binding = 1) uniform cb1\n"
"{\n"
"	vec3 FogColor;\n"
"	float AREF;\n"
"	vec4 WH;\n"
"	vec2 TA;\n"
"	float MaxDepthPS;\n"
"	float Af;\n"
"	uvec4 FbMask;\n"
"	vec4 HalfTexel;\n"
"	vec4 MinMax;\n"
"	vec4 LODParams;\n"
"	vec4 STRange;\n"
"	ivec4 ChannelShuffle;\n"
"	vec2 TC_OffsetHack;\n"
"	vec2 STScale;\n"
"	mat4 DitherMatrix;\n"
"	float ScaledScaleFactor;\n"
"	float RcpScaleFactor;\n"
"};\n"
"\n"
"layout(location = 0) in VSOutput\n"
"{\n"
"	vec4 t;\n"
"	vec4 ti;\n"
"	#if PS_IIP != 0\n"
"		vec4 c;\n"
"	#else\n"
"		flat vec4 c;\n"
"	#endif\n"
"} vsIn;\n"
"\n"
"#if !PS_NO_COLOR && !PS_NO_COLOR1\n"
"layout(location = 0, index = 0) out vec4 o_col0;\n"
"layout(location = 0, index = 1) out vec4 o_col1;\n"
"#elif !PS_NO_COLOR\n"
"layout(location = 0) out vec4 o_col0;\n"
"#endif\n"
"\n"
"#if NEEDS_TEX\n"
"layout(set = 1, binding = 0) uniform sampler2D Texture;\n"
"layout(set = 1, binding = 1) uniform texture2D Palette;\n"
"#endif\n"
"\n"
"#if PS_FEEDBACK_LOOP_IS_NEEDED\n"
"	#if defined(DISABLE_TEXTURE_BARRIER)\n"
"		layout(set = 2, binding = 0) uniform texture2D RtSampler;\n"
"		vec4 sample_from_rt() { return texelFetch(RtSampler, ivec2(gl_FragCoord.xy), 0); }\n"
"	#else\n"
"		layout(input_attachment_index = 0, set = 2, binding = 0) uniform subpassInput RtSampler;\n"
"		vec4 sample_from_rt() { return subpassLoad(RtSampler); }\n"
"	#endif\n"
"#endif\n"
"\n"
"#if PS_DATE > 0\n"
"layout(set = 2, binding = 1) uniform texture2D PrimMinTexture;\n"
"#endif\n"
"\n"
"#if NEEDS_TEX\n"
"\n"
"vec4 sample_c(vec2 uv)\n"
"{\n"
"#if PS_TEX_IS_FB\n"
"	return sample_from_rt();\n"
"#elif PS_REGION_RECT\n"
"	return texelFetch(Texture, ivec2(uv), 0);\n"
"#else\n"
"#if !PS_ADJS && !PS_ADJT\n"
"	uv *= STScale;\n"
"#else\n"
"	#if PS_ADJS\n"
"		uv.x = (uv.x - STRange.x) * STRange.z;\n"
"	#else\n"
"		uv.x = uv.x * STScale.x;\n"
"	#endif\n"
"	#if PS_ADJT\n"
"		uv.y = (uv.y - STRange.y) * STRange.w;\n"
"	#else\n"
"		uv.y = uv.y * STScale.y;\n"
"	#endif\n"
"#endif\n"
"\n"
"#if PS_AUTOMATIC_LOD == 1\n"
"	return texture(Texture, uv);\n"
"#elif PS_MANUAL_LOD == 1\n"
"	// FIXME add LOD: K - ( LOG2(Q) * (1 << L))\n"
"	float K = LODParams.x;\n"
"	float L = LODParams.y;\n"
"	float bias = LODParams.z;\n"
"	float max_lod = LODParams.w;\n"
"\n"
"	float gs_lod = K - log2(abs(vsIn.t.w)) * L;\n"
"	// FIXME max useful ?\n"
"	//float lod = max(min(gs_lod, max_lod) - bias, 0.0f);\n"
"	float lod = min(gs_lod, max_lod) - bias;\n"
"\n"
"	return textureLod(Texture, uv, lod);\n"
"#else\n"
"	return textureLod(Texture, uv, 0); // No lod\n"
"#endif\n"
"#endif\n"
"}\n"
"\n"
"vec4 sample_p(uint idx)\n"
"{\n"
"	return texelFetch(Palette, ivec2(int(idx), 0), 0);\n"
"}\n"
"\n"
"vec4 sample_p_norm(float u)\n"
"{\n"
"	return sample_p(uint(u * 255.5f));\n"
"}\n"
"\n"
"vec4 clamp_wrap_uv(vec4 uv)\n"
"{\n"
"	vec4 tex_size = WH.xyxy;\n"
"\n"
"	#if PS_WMS == PS_WMT\n"
"	{\n"
"		#if PS_REGION_RECT == 1 && PS_WMS == 0\n"
"		{\n"
"			uv = fract(uv);\n"
"		}\n"
"		#elif PS_REGION_RECT == 1 && PS_WMS == 1\n"
"		{\n"
"			uv = clamp(uv, vec4(0.0f), vec4(1.0f));\n"
"		}\n"
"		#elif PS_WMS == 2\n"
"		{\n"
"			uv = clamp(uv, MinMax.xyxy, MinMax.zwzw);\n"
"		}\n"
"		#elif PS_WMS == 3\n"
"		{\n"
"			#if PS_FST == 0\n"
"			// wrap negative uv coords to avoid an off by one error that shifted\n"
"			// textures. Fixes Xenosaga's hair issue.\n"
"			uv = fract(uv);\n"
"			#endif\n"
"			uv = vec4((uvec4(uv * tex_size) & floatBitsToUint(MinMax.xyxy)) | floatBitsToUint(MinMax.zwzw)) / tex_size;\n"
"		}\n"
"		#endif\n"
"	}\n"
"	#else\n"
"	{\n"
"		#if PS_REGION_RECT == 1 && PS_WMS == 0\n"
"		{\n"
"			uv.xz = fract(uv.xz);\n"
"		}\n"
"		#elif PS_REGION_RECT == 1 && PS_WMS == 1\n"
"		{\n"
"			uv.xz = clamp(uv.xz, vec2(0.0f), vec2(1.0f));\n"
"		}\n"
"		#elif PS_WMS == 2\n"
"		{\n"
"			uv.xz = clamp(uv.xz, MinMax.xx, MinMax.zz);\n"
"		}\n"
"		#elif PS_WMS == 3\n"
"		{\n"
"			#if PS_FST == 0\n"
"			uv.xz = fract(uv.xz);\n"
"			#endif\n"
"			uv.xz = vec2((uvec2(uv.xz * tex_size.xx) & floatBitsToUint(MinMax.xx)) | floatBitsToUint(MinMax.zz)) / tex_size.xx;\n"
"		}\n"
"		#endif\n"
"		#if PS_REGION_RECT == 1 && PS_WMT == 0\n"
"		{\n"
"			uv.yw = fract(uv.yw);\n"
"		}\n"
"		#elif PS_REGION_RECT == 1 && PS_WMT == 1\n"
"		{\n"
"			uv.yw = clamp(uv.yw, vec2(0.0f), vec2(1.0f));\n"
"		}\n"
"		#elif PS_WMT == 2\n"
"		{\n"
"			uv.yw = clamp(uv.yw, MinMax.yy, MinMax.ww);\n"
"		}\n"
"		#elif PS_WMT == 3\n"
"		{\n"
"			#if PS_FST == 0\n"
"			uv.yw = fract(uv.yw);\n"
"			#endif\n"
"			uv.yw = vec2((uvec2(uv.yw * tex_size.yy) & floatBitsToUint(MinMax.yy)) | floatBitsToUint(MinMax.ww)) / tex_size.yy;\n"
"		}\n"
"		#endif\n"
"	}\n"
"	#endif\n"
"\n"
"	#if PS_REGION_RECT == 1\n"
"		// Normalized -> Integer Coordinates.\n"
"		uv = clamp(uv * WH.zwzw + STRange.xyxy, STRange.xyxy, STRange.zwzw);\n"
"	#endif\n"
"\n"
"	return uv;\n"
"}\n"
"\n"
"mat4 sample_4c(vec4 uv)\n"
"{\n"
"	mat4 c;\n"
"\n"
"	c[0] = sample_c(uv.xy);\n"
"	c[1] = sample_c(uv.zy);\n"
"	c[2] = sample_c(uv.xw);\n"
"	c[3] = sample_c(uv.zw);\n"
"\n"
"	return c;\n"
"}\n"
"\n"
"uvec4 sample_4_index(vec4 uv)\n"
"{\n"
"	vec4 c;\n"
"\n"
"	c.x = sample_c(uv.xy).a;\n"
"	c.y = sample_c(uv.zy).a;\n"
"	c.z = sample_c(uv.xw).a;\n"
"	c.w = sample_c(uv.zw).a;\n"
"\n"
"	// Denormalize value\n"
"			\n"
"#if PS_RTA_SRC_CORRECTION\n"
"	uvec4 i = uvec4(round(c * 128.25f));\n"
"#else\n"
"	uvec4 i = uvec4(c * 255.5f);\n"
"#endif\n"
"\n"
"	#if PS_PAL_FMT == 1\n"
"		// 4HL\n"
"		return i & 0xFu;\n"
"	#elif PS_PAL_FMT == 2\n"
"		// 4HH\n"
"		return i >> 4u;\n"
"	#else\n"
"		// 8\n"
"		return i;\n"
"	#endif\n"
"}\n"
"\n"
"mat4 sample_4p(uvec4 u)\n"
"{\n"
"	mat4 c;\n"
"\n"
"	c[0] = sample_p(u.x);\n"
"	c[1] = sample_p(u.y);\n"
"	c[2] = sample_p(u.z);\n"
"	c[3] = sample_p(u.w);\n"
"\n"
"	return c;\n"
"}\n"
"\n"
"int fetch_raw_depth(ivec2 xy)\n"
"{\n"
"#if PS_TEX_IS_FB\n"
"	vec4 col = sample_from_rt();\n"
"#else\n"
"	vec4 col = texelFetch(Texture, xy, 0);\n"
"#endif\n"
"	return int(col.r * exp2(32.0f));\n"
"}\n"
"\n"
"vec4 fetch_raw_color(ivec2 xy)\n"
"{\n"
"#if PS_TEX_IS_FB\n"
"	return sample_from_rt();\n"
"#else\n"
"	return texelFetch(Texture, xy, 0);\n"
"#endif\n"
"}\n"
"\n"
"vec4 fetch_c(ivec2 uv)\n"
"{\n"
"#if PS_TEX_IS_FB\n"
"	return sample_from_rt();\n"
"#else\n"
"	return texelFetch(Texture, uv, 0);\n"
"#endif\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// Depth sampling\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ivec2 clamp_wrap_uv_depth(ivec2 uv)\n"
"{\n"
"	ivec4 mask = floatBitsToInt(MinMax) << 4;\n"
"	#if (PS_WMS == PS_WMT)\n"
"	{\n"
"		#if (PS_WMS == 2)\n"
"		{\n"
"			uv = clamp(uv, mask.xy, mask.zw);\n"
"		}\n"
"		#elif (PS_WMS == 3)\n"
"		{\n"
"			uv = (uv & mask.xy) | mask.zw;\n"
"		}\n"
"		#endif\n"
"	}\n"
"	#else\n"
"	{\n"
"		#if (PS_WMS == 2)\n"
"		{\n"
"			uv.x = clamp(uv.x, mask.x, mask.z);\n"
"		}\n"
"		#elif (PS_WMS == 3)\n"
"		{\n"
"			uv.x = (uv.x & mask.x) | mask.z;\n"
"		}\n"
"		#endif\n"
"		#if (PS_WMT == 2)\n"
"		{\n"
"			uv.y = clamp(uv.y, mask.y, mask.w);\n"
"		}\n"
"		#elif (PS_WMT == 3)\n"
"		{\n"
"			uv.y = (uv.y & mask.y) | mask.w;\n"
"		}\n"
"		#endif\n"
"	}\n"
"	#endif\n"
"	return uv;\n"
"}\n"
"\n"
"vec4 sample_depth(vec2 st, ivec2 pos)\n"
"{\n"
"	vec2 uv_f = vec2(clamp_wrap_uv_depth(ivec2(st))) * vec2(ScaledScaleFactor);\n"
"\n"
"	#if PS_REGION_RECT == 1\n"
"		uv_f = clamp(uv_f + STRange.xy, STRange.xy, STRange.zw);\n"
"	#endif\n"
"\n"
"	ivec2 uv = ivec2(uv_f);\n"
"	vec4 t = vec4(0.0f);\n"
"\n"
"	#if (PS_TALES_OF_ABYSS_HLE == 1)\n"
"	{\n"
"		// Warning: UV can't be used in channel effect\n"
"		int depth = fetch_raw_depth(pos);\n"
"\n"
"		// Convert msb based on the palette\n"
"		t = texelFetch(Palette, ivec2((depth >> 8) & 0xFF, 0), 0) * 255.0f;\n"
"	}\n"
"	#elif (PS_URBAN_CHAOS_HLE == 1)\n"
"	{\n"
"		// Depth buffer is read as a RGB5A1 texture. The game try to extract the green channel.\n"
"		// So it will do a first channel trick to extract lsb, value is right-shifted.\n"
"		// Then a new channel trick to extract msb which will shifted to the left.\n"
"		// OpenGL uses a vec32 format for the depth so it requires a couple of conversion.\n"
"		// To be faster both steps (msb&lsb) are done in a single pass.\n"
"\n"
"		// Warning: UV can't be used in channel effect\n"
"		int depth = fetch_raw_depth(pos);\n"
"\n"
"		// Convert lsb based on the palette\n"
"		t = texelFetch(Palette, ivec2(depth & 0xFF, 0), 0) * 255.0f;\n"
"\n"
"		// Msb is easier\n"
"		float green = float(((depth >> 8) & 0xFF) * 36.0f);\n"
"		green = min(green, 255.0f);\n"
"		t.g += green;\n"
"	}\n"
"	#elif (PS_DEPTH_FMT == 1)\n"
"	{\n"
"		// Based on ps_convert_float32_rgba8 of convert\n"
"\n"
"		// Convert a vec32 depth texture into a RGBA color texture\n"
"		uint d = uint(fetch_c(uv).r * exp2(32.0f));\n"
"		t = vec4(uvec4((d & 0xFFu), ((d >> 8) & 0xFFu), ((d >> 16) & 0xFFu), (d >> 24)));\n"
"	}\n"
"	#elif (PS_DEPTH_FMT == 2)\n"
"	{\n"
"		// Based on ps_convert_float16_rgb5a1 of convert\n"
"\n"
"		// Convert a vec32 (only 16 lsb) depth into a RGB5A1 color texture\n"
"		uint d = uint(fetch_c(uv).r * exp2(32.0f));\n"
"		t = vec4(uvec4((d & 0x1Fu), ((d >> 5) & 0x1Fu), ((d >> 10) & 0x1Fu), (d >> 15) & 0x01u)) * vec4(8.0f, 8.0f, 8.0f, 128.0f);\n"
"	}\n"
"	#elif (PS_DEPTH_FMT == 3)\n"
"	{\n"
"		// Convert a RGBA/RGB5A1 color texture into a RGBA/RGB5A1 color texture\n"
"		t = fetch_c(uv) * 255.0f;\n"
"	}\n"
"	#endif\n"
"\n"
"	#if (PS_AEM_FMT == FMT_24)\n"
"	{\n"
"		t.a = ((PS_AEM == 0) || any(bvec3(t.rgb))) ? 255.0f * TA.x : 0.0f;\n"
"	}\n"
"	#elif (PS_AEM_FMT == FMT_16)\n"
"	{\n"
"		t.a = t.a >= 128.0f ? 255.0f * TA.y : ((PS_AEM == 0) || any(bvec3(t.rgb))) ? 255.0f * TA.x : 0.0f;\n"
"	}\n"
"	#elif PS_PAL_FMT != 0 && !PS_TALES_OF_ABYSS_HLE && !PS_URBAN_CHAOS_HLE\n"
"	{\n"
"		t = trunc(sample_4p(uvec4(t.aaaa))[0] * 255.0f + 0.05f);\n"
"	}\n"
"	#endif\n"
"\n"
"	return t;\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// Fetch a Single Channel\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"vec4 fetch_red(ivec2 xy)\n"
"{\n"
"	vec4 rt;\n"
"\n"
"	#if (PS_DEPTH_FMT == 1) || (PS_DEPTH_FMT == 2)\n"
"		int depth = (fetch_raw_depth(xy)) & 0xFF;\n"
"		rt = vec4(float(depth) / 255.0f);\n"
"	#else\n"
"		rt = fetch_raw_color(xy);\n"
"	#endif\n"
"\n"
"	return sample_p_norm(rt.r) * 255.0f;\n"
"}\n"
"\n"
"vec4 fetch_green(ivec2 xy)\n"
"{\n"
"	vec4 rt;\n"
"\n"
"	#if (PS_DEPTH_FMT == 1) || (PS_DEPTH_FMT == 2)\n"
"		int depth = (fetch_raw_depth(xy) >> 8) & 0xFF;\n"
"		rt = vec4(float(depth) / 255.0f);\n"
"	#else\n"
"		rt = fetch_raw_color(xy);\n"
"	#endif\n"
"\n"
"	return sample_p_norm(rt.g) * 255.0f;\n"
"}\n"
"\n"
"vec4 fetch_blue(ivec2 xy)\n"
"{\n"
"	vec4 rt;\n"
"\n"
"	#if (PS_DEPTH_FMT == 1) || (PS_DEPTH_FMT == 2)\n"
"		int depth = (fetch_raw_depth(xy) >> 16) & 0xFF;\n"
"		rt = vec4(float(depth) / 255.0f);\n"
"	#else\n"
"		rt = fetch_raw_color(xy);\n"
"	#endif\n"
"\n"
"	return sample_p_norm(rt.b) * 255.0f;\n"
"}\n"
"\n"
"vec4 fetch_alpha(ivec2 xy)\n"
"{\n"
"	vec4 rt = fetch_raw_color(xy);\n"
"	return sample_p_norm(rt.a) * 255.0f;\n"
"}\n"
"\n"
"vec4 fetch_rgb(ivec2 xy)\n"
"{\n"
"	vec4 rt = fetch_raw_color(xy);\n"
"	vec4 c = vec4(sample_p_norm(rt.r).r, sample_p_norm(rt.g).g, sample_p_norm(rt.b).b, 1.0);\n"
"	return c * 255.0f;\n"
"}\n"
"\n"
"vec4 fetch_gXbY(ivec2 xy)\n"
"{\n"
"	#if (PS_DEPTH_FMT == 1) || (PS_DEPTH_FMT == 2)\n"
"		int depth = fetch_raw_depth(xy);\n"
"		int bg = (depth >> (8 + ChannelShuffle.w)) & 0xFF;\n"
"		return vec4(bg);\n"
"	#else\n"
"		ivec4 rt = ivec4(fetch_raw_color(xy) * 255.0);\n"
"		int green = (rt.g >> ChannelShuffle.w) & ChannelShuffle.z;\n"
"		int blue = (rt.b << ChannelShuffle.y) & ChannelShuffle.x;\n"
"		return vec4(float(green | blue));\n"
"	#endif\n"
"}\n"
"\n"
"vec4 sample_color(vec2 st)\n"
"{\n"
"	#if PS_TCOFFSETHACK\n"
"	st += TC_OffsetHack.xy;\n"
"	#endif\n"
"\n"
"	vec4 t;\n"
"	mat4 c;\n"
"	vec2 dd;\n"
"\n"
"	#if PS_LTF == 0 && PS_AEM_FMT == FMT_32 && PS_PAL_FMT == 0 && PS_REGION_RECT == 0 && PS_WMS < 2 && PS_WMT < 2\n"
"	{\n"
"		c[0] = sample_c(st);\n"
"	}\n"
"	#else\n"
"	{\n"
"		vec4 uv;\n"
"\n"
"		#if PS_LTF\n"
"		{\n"
"			uv = st.xyxy + HalfTexel;\n"
"			dd = fract(uv.xy * WH.zw);\n"
"\n"
"			#if PS_FST == 0\n"
"			{\n"
"				dd = clamp(dd, vec2(0.0f), vec2(0.9999999f));\n"
"			}\n"
"			#endif\n"
"		}\n"
"		#else\n"
"		{\n"
"			uv = st.xyxy;\n"
"		}\n"
"		#endif\n"
"\n"
"		uv = clamp_wrap_uv(uv);\n"
"\n"
"#if PS_PAL_FMT != 0\n"
"			c = sample_4p(sample_4_index(uv));\n"
"#else\n"
"			c = sample_4c(uv);\n"
"#endif\n"
"	}\n"
"	#endif\n"
"\n"
"	for (uint i = 0; i < 4; i++)\n"
"	{\n"
"		#if (PS_AEM_FMT == FMT_24)\n"
"			c[i].a = (PS_AEM == 0 || any(bvec3(c[i].rgb))) ? TA.x : 0.0f;\n"
"		#elif (PS_AEM_FMT == FMT_16)\n"
"			c[i].a = (c[i].a >= 0.5) ? TA.y : ((PS_AEM == 0 || any(bvec3(ivec3(c[i].rgb * 255.0f) & ivec3(0xF8)))) ? TA.x : 0.0f);\n"
"		#endif\n"
"	}\n"
"\n"
"	#if PS_LTF\n"
"	{\n"
"		t = mix(mix(c[0], c[1], dd.x), mix(c[2], c[3], dd.x), dd.y);\n"
"	}\n"
"	#else\n"
"	{\n"
"		t = c[0];\n"
"	}\n"
"	#endif\n"
"#if PS_AEM_FMT == FMT_32 && PS_PAL_FMT == 0 && PS_RTA_SRC_CORRECTION\n"
"	t.a = t.a * (128.5f / 255.0f);\n"
"#endif\n"
"	return trunc(t * 255.0f + 0.05f);\n"
"}\n"
"\n"
"#endif // NEEDS_TEX\n"
"\n"
"vec4 tfx(vec4 T, vec4 C)\n"
"{\n"
"	vec4 C_out;\n"
"	vec4 FxT = trunc((C * T) / 128.0f);\n"
"\n"
"#if (PS_TFX == 0)\n"
"	C_out = FxT;\n"
"#elif (PS_TFX == 1)\n"
"	C_out = T;\n"
"#elif (PS_TFX == 2)\n"
"	C_out.rgb = FxT.rgb + C.a;\n"
"	C_out.a = T.a + C.a;\n"
"#elif (PS_TFX == 3)\n"
"	C_out.rgb = FxT.rgb + C.a;\n"
"	C_out.a = T.a;\n"
"#else\n"
"	C_out = C;\n"
"#endif\n"
"\n"
"#if (PS_TCC == 0)\n"
"	C_out.a = C.a;\n"
"#endif\n"
"\n"
"#if (PS_TFX == 0) || (PS_TFX == 2) || (PS_TFX == 3)\n"
"	// Clamp only when it is useful\n"
"	C_out = min(C_out, 255.0f);\n"
"#endif\n"
"\n"
"	return C_out;\n"
"}\n"
"\n"
"bool atst(vec4 C)\n"
"{\n"
"	float a = C.a;\n"
"\n"
"	#if (PS_ATST == 1)\n"
"	{\n"
"		return (a <= AREF);\n"
"	}\n"
"	#elif (PS_ATST == 2)\n"
"	{\n"
"		return (a >= AREF);\n"
"	}\n"
"	#elif (PS_ATST == 3)\n"
"	{\n"
"		return (abs(a - AREF) <= 0.5f);\n"
"	}\n"
"	#elif (PS_ATST == 4)\n"
"	{\n"
"		return (abs(a - AREF) >= 0.5f);\n"
"	}\n"
"	#else\n"
"	{\n"
"		// nothing to do\n"
"		return true;\n"
"	}\n"
"	#endif\n"
"}\n"
"\n"
"vec4 fog(vec4 c, float f)\n"
"{\n"
"	#if PS_FOG\n"
"		c.rgb = trunc(mix(FogColor, c.rgb, f));\n"
"	#endif\n"
"\n"
"	return c;\n"
"}\n"
"\n"
"vec4 ps_color()\n"
"{\n"
"#if PS_FST == 0\n"
"	vec2 st = vsIn.t.xy / vsIn.t.w;\n"
"	vec2 st_int = vsIn.ti.zw / vsIn.t.w;\n"
"#else\n"
"	vec2 st = vsIn.ti.xy;\n"
"	vec2 st_int = vsIn.ti.zw;\n"
"#endif\n"
"\n"
"#if !NEEDS_TEX\n"
"	vec4 T = vec4(0.0f);\n"
"#elif PS_CHANNEL_FETCH == 1\n"
"	vec4 T = fetch_red(ivec2(gl_FragCoord.xy));\n"
"#elif PS_CHANNEL_FETCH == 2\n"
"	vec4 T = fetch_green(ivec2(gl_FragCoord.xy));\n"
"#elif PS_CHANNEL_FETCH == 3\n"
"	vec4 T = fetch_blue(ivec2(gl_FragCoord.xy));\n"
"#elif PS_CHANNEL_FETCH == 4\n"
"	vec4 T = fetch_alpha(ivec2(gl_FragCoord.xy));\n"
"#elif PS_CHANNEL_FETCH == 5\n"
"	vec4 T = fetch_rgb(ivec2(gl_FragCoord.xy));\n"
"#elif PS_CHANNEL_FETCH == 6\n"
"	vec4 T = fetch_gXbY(ivec2(gl_FragCoord.xy));\n"
"#elif PS_DEPTH_FMT > 0\n"
"	vec4 T = sample_depth(st_int, ivec2(gl_FragCoord.xy));\n"
"#else\n"
"	vec4 T = sample_color(st);\n"
"#endif\n"
"\n"
"	#if PS_SHUFFLE && !PS_READ16_SRC && !PS_SHUFFLE_SAME\n"
"		uvec4 denorm_c_before = uvec4(T);\n"
"		#if (PS_PROCESS_BA & SHUFFLE_READ)\n"
"			T.r = float((denorm_c_before.b << 3) & 0xF8);\n"
"			T.g = float(((denorm_c_before.b >> 2) & 0x38) | ((denorm_c_before.a << 6) & 0xC0));\n"
"			T.b = float((denorm_c_before.a << 1) & 0xF8);\n"
"			T.a = float(denorm_c_before.a & 0x80);\n"
"		#else\n"
"			T.r = float((denorm_c_before.r << 3) & 0xF8);\n"
"			T.g = float(((denorm_c_before.r >> 2) & 0x38) | ((denorm_c_before.g << 6) & 0xC0));\n"
"			T.b = float((denorm_c_before.g << 1) & 0xF8);\n"
"			T.a = float(denorm_c_before.g & 0x80);\n"
"		#endif\n"
"		T.a = ((T.a >= 127.5f) ? TA.y : ((PS_AEM == 0 || any(bvec3(ivec3(T.rgb) & ivec3(0xF8)))) ? TA.x : 0.0f)) * 255.0f;\n"
"	#endif\n"
"	\n"
"	vec4 C = tfx(T, vsIn.c);\n"
"\n"
"	C = fog(C, vsIn.t.z);\n"
"\n"
"	return C;\n"
"}\n"
"\n"
"void ps_fbmask(inout vec4 C)\n"
"{\n"
"	#if PS_FBMASK\n"
"		vec4 RT = trunc(sample_from_rt() * 255.0f + 0.1f);\n"
"		C = vec4((uvec4(C) & ~FbMask) | (uvec4(RT) & FbMask));\n"
"	#endif\n"
"}\n"
"\n"
"void ps_dither(inout vec3 C, float As)\n"
"{\n"
"	#if PS_DITHER > 0 && PS_DITHER < 3\n"
"		ivec2 fpos;\n"
"\n"
"		#if PS_DITHER == 2\n"
"			fpos = ivec2(gl_FragCoord.xy);\n"
"		#else\n"
"			fpos = ivec2(gl_FragCoord.xy * RcpScaleFactor);\n"
"		#endif\n"
"\n"
"		float value = DitherMatrix[fpos.y & 3][fpos.x & 3];\n"
"		\n"
"		// The idea here is we add on the dither amount adjusted by the alpha before it goes to the hw blend\n"
"		// so after the alpha blend the resulting value should be the same as (Cs - Cd) * As + Cd + Dither.\n"
"		#if PS_DITHER_ADJUST\n"
"			#if PS_BLEND_C == 2\n"
"				float Alpha = Af;\n"
"			#else\n"
"				float Alpha = As;\n"
"			#endif\n"
"\n"
"			value *= Alpha > 0.0f ? min(1.0f / Alpha, 1.0f) : 1.0f;\n"
"		#endif\n"
"		\n"
"		#if PS_ROUND_INV\n"
"			C -= value;\n"
"		#else\n"
"			C += value;\n"
"		#endif\n"
"	#endif\n"
"}\n"
"\n"
"void ps_color_clamp_wrap(inout vec3 C)\n"
"{\n"
"	// When dithering the bottom 3 bits become meaningless and cause lines in the picture\n"
"	// so we need to limit the color depth on dithered items\n"
"#if SW_BLEND || (PS_DITHER > 0 && PS_DITHER < 3) || PS_FBMASK\n"
"\n"
"#if PS_DST_FMT == FMT_16 && PS_BLEND_MIX == 0 && PS_ROUND_INV\n"
"	C += 7.0f; // Need to round up, not down since the shader will invert\n"
"#endif\n"
"\n"
"	// Correct the Color value based on the output format\n"
"#if PS_COLCLIP == 0 && PS_HDR == 0\n"
"	// Standard Clamp\n"
"	C = clamp(C, vec3(0.0f), vec3(255.0f));\n"
"#endif\n"
"\n"
"	// FIXME rouding of negative float?\n"
"	// compiler uses trunc but it might need floor\n"
"\n"
"	// Warning: normally blending equation is mult(A, B) = A * B >> 7. GPU have the full accuracy\n"
"	// GS: Color = 1, Alpha = 255 => output 1\n"
"	// GPU: Color = 1/255, Alpha = 255/255 * 255/128 => output 1.9921875\n"
"#if PS_DST_FMT == FMT_16 && PS_DITHER != 3 && (PS_BLEND_MIX == 0 || PS_DITHER > 0)\n"
"	// In 16 bits format, only 5 bits of colors are used. It impacts shadows computation of Castlevania\n"
"	C = vec3(ivec3(C) & ivec3(0xF8));\n"
"#elif PS_COLCLIP == 1 || PS_HDR == 1\n"
"	C = vec3(ivec3(C) & ivec3(0xFF));\n"
"#endif\n"
"\n"
"#endif\n"
"}\n"
"\n"
"void ps_blend(inout vec4 Color, inout vec4 As_rgba)\n"
"{\n"
"	float As = As_rgba.a;\n"
"\n"
"	#if SW_BLEND\n"
"\n"
"		// PABE\n"
"		#if PS_PABE\n"
"			// No blending so early exit\n"
"			if (As < 1.0f)\n"
"				return;\n"
"		#endif\n"
"\n"
"		#if PS_FEEDBACK_LOOP_IS_NEEDED\n"
"			vec4 RT = sample_from_rt();\n"
"		#else\n"
"			// Not used, but we define it to make the selection below simpler.\n"
"			vec4 RT = vec4(0.0f);\n"
"		#endif\n"
"\n"
"		#if PS_RTA_CORRECTION\n"
"			float Ad = trunc(RT.a * 128.0f + 0.1f) / 128.0f;\n"
"		#else\n"
"			float Ad = trunc(RT.a * 255.0f + 0.1f) / 128.0f;\n"
"		#endif\n"
"		\n"
"		#if PS_SHUFFLE && PS_FEEDBACK_LOOP_IS_NEEDED\n"
"			uvec4 denorm_rt = uvec4(RT);\n"
"			#if (PS_PROCESS_BA & SHUFFLE_WRITE)\n"
"				RT.r = float((denorm_rt.b << 3) & 0xF8);\n"
"				RT.g = float(((denorm_rt.b >> 2) & 0x38) | ((denorm_rt.a << 6) & 0xC0));\n"
"				RT.b = float((denorm_rt.a << 1) & 0xF8);\n"
"				RT.a = float(denorm_rt.a & 0x80);\n"
"			#else\n"
"				RT.r = float((denorm_rt.r << 3) & 0xF8);\n"
"				RT.g = float(((denorm_rt.r >> 2) & 0x38) | ((denorm_rt.g << 6) & 0xC0));\n"
"				RT.b = float((denorm_rt.g << 1) & 0xF8);\n"
"				RT.a = float(denorm_rt.g & 0x80);\n"
"			#endif\n"
"		#endif\n"
"\n"
"			// Let the compiler do its jobs !\n"
"			vec3 Cd = trunc(RT.rgb * 255.0f + 0.1f);\n"
"			vec3 Cs = Color.rgb;\n"
"\n"
"		#if PS_BLEND_A == 0\n"
"			vec3 A = Cs;\n"
"		#elif PS_BLEND_A == 1\n"
"			vec3 A = Cd;\n"
"		#else\n"
"			vec3 A = vec3(0.0f);\n"
"		#endif\n"
"\n"
"		#if PS_BLEND_B == 0\n"
"			vec3 B = Cs;\n"
"		#elif PS_BLEND_B == 1\n"
"			vec3 B = Cd;\n"
"		#else\n"
"			vec3 B = vec3(0.0f);\n"
"		#endif\n"
"\n"
"		#if PS_BLEND_C == 0\n"
"			float C = As;\n"
"		#elif PS_BLEND_C == 1\n"
"			float C = Ad;\n"
"		#else\n"
"			float C = Af;\n"
"		#endif\n"
"\n"
"		#if PS_BLEND_D == 0\n"
"			vec3 D = Cs;\n"
"		#elif PS_BLEND_D == 1\n"
"			vec3 D = Cd;\n"
"		#else\n"
"			vec3 D = vec3(0.0f);\n"
"		#endif\n"
"\n"
"		// As/Af clamp alpha for Blend mix\n"
"		// We shouldn't clamp blend mix with blend hw 1 as we want alpha higher\n"
"		float C_clamped = C;\n"
"		#if PS_BLEND_MIX > 0 && PS_BLEND_HW != 1 && PS_BLEND_HW != 2\n"
"			C_clamped = min(C_clamped, 1.0f);\n"
"		#endif\n"
"\n"
"		#if PS_BLEND_A == PS_BLEND_B\n"
"			Color.rgb = D;\n"
"		// In blend_mix, HW adds on some alpha factor * dst.\n"
"		// Truncating here wouldn't quite get the right result because it prevents the <1 bit here from combining with a <1 bit in dst to form a â‰¥1 amount that pushes over the truncation.\n"
"		// Instead, apply an offset to convert HW's round to a floor.\n"
"		// Since alpha is in 1/128 increments, subtracting (0.5 - 0.5/128 == 127/256) would get us what we want if GPUs blended in full precision.\n"
"		// But they don't.  Details here: https://github.com/PCSX2/pcsx2/pull/6809#issuecomment-1211473399\n"
"		// Based on the scripts at the above link, the ideal choice for Intel GPUs is 126/256, AMD 120/256.  Nvidia is a lost cause.\n"
"		// 124/256 seems like a reasonable compromise, providing the correct answer 99.3% of the time on Intel (vs 99.6% for 126/256), and 97% of the time on AMD (vs 97.4% for 120/256).\n"
"		#elif PS_BLEND_MIX == 2\n"
"			Color.rgb = ((A - B) * C_clamped + D) + (124.0f/256.0f);\n"
"		#elif PS_BLEND_MIX == 1\n"
"			Color.rgb = ((A - B) * C_clamped + D) - (124.0f/256.0f);\n"
"		#else\n"
"				Color.rgb = trunc((A - B) * C + D);\n"
"		#endif\n"
"\n"
"		#if PS_BLEND_HW == 1\n"
"			// As or Af\n"
"			As_rgba.rgb = vec3(C);\n"
"			// Subtract 1 for alpha to compensate for the changed equation,\n"
"			// if c.rgb > 255.0f then we further need to adjust alpha accordingly,\n"
"			// we pick the lowest overflow from all colors because it's the safest,\n"
"			// we divide by 255 the color because we don't know Cd value,\n"
"			// changed alpha should only be done for hw blend.\n"
"			vec3 alpha_compensate = max(vec3(1.0f), Color.rgb / vec3(255.0f));\n"
"			As_rgba.rgb -= alpha_compensate;\n"
"		#elif PS_BLEND_HW == 2\n"
"			// Since we can't do Cd*(Aalpha + 1) - Cs*Alpha in hw blend\n"
"			// what we can do is adjust the Cs value that will be\n"
"			// subtracted, this way we can get a better result in hw blend.\n"
"			// Result is still wrong but less wrong than before.\n"
"			float division_alpha = 1.0f + C;\n"
"			Color.rgb /= vec3(division_alpha);\n"
"		#elif PS_BLEND_HW == 3\n"
"			// As, Ad or Af clamped.\n"
"			As_rgba.rgb = vec3(C_clamped);\n"
"			// Cs*(Alpha + 1) might overflow, if it does then adjust alpha value\n"
"			// that is sent on second output to compensate.\n"
"			vec3 overflow_check = (Color.rgb - vec3(255.0f)) / 255.0f;\n"
"			vec3 alpha_compensate = max(vec3(0.0f), overflow_check);\n"
"			As_rgba.rgb -= alpha_compensate;\n"
"		#endif\n"
"\n"
"	#else\n"
"		#if PS_BLEND_HW == 1\n"
"			// Needed for Cd * (As/Ad/F + 1) blending modes\n"
"			Color.rgb = vec3(255.0f);\n"
"		#elif PS_BLEND_HW == 2\n"
"			// Cd*As,Cd*Ad or Cd*F\n"
"\n"
"			#if PS_BLEND_C == 2\n"
"				float Alpha = Af;\n"
"			#else\n"
"				float Alpha = As;\n"
"			#endif\n"
"\n"
"			Color.rgb = max(vec3(0.0f), (Alpha - vec3(1.0f)));\n"
"			Color.rgb *= vec3(255.0f);\n"
"		#elif PS_BLEND_HW == 3 && PS_RTA_CORRECTION == 0\n"
"			// Needed for Cs*Ad, Cs*Ad + Cd, Cd - Cs*Ad\n"
"			// Multiply Color.rgb by (255/128) to compensate for wrong Ad/255 value when rgb are below 128.\n"
"			// When any color channel is higher than 128 then adjust the compensation automatically\n"
"			// to give us more accurate colors, otherwise they will be wrong.\n"
"			// The higher the value (>128) the lower the compensation will be.\n"
"			float max_color = max(max(Color.r, Color.g), Color.b);\n"
"			float color_compensate = 255.0f / max(128.0f, max_color);\n"
"			Color.rgb *= vec3(color_compensate);\n"
"		#elif PS_BLEND_HW == 4\n"
"			// Needed for Cd * (1 - Ad)\n"
"			Color.rgb = vec3(128.0f);\n"
"		#endif\n"
"	#endif\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"#if PS_SCANMSK & 2\n"
"	// fail depth test on prohibited lines\n"
"	if ((int(gl_FragCoord.y) & 1) == (PS_SCANMSK & 1))\n"
"		discard;\n"
"#endif\n"
"#if PS_DATE >= 5\n"
"\n"
"#if PS_WRITE_RG == 1\n"
"	// Pseudo 16 bits access.\n"
"	float rt_a = sample_from_rt().g;\n"
"#else\n"
"	float rt_a = sample_from_rt().a;\n"
"#endif\n"
"\n"
"#if (PS_DATE & 3) == 1\n"
"	// DATM == 0: Pixel with alpha equal to 1 will failed\n"
"	#if PS_RTA_CORRECTION\n"
"		bool bad = (254.5f / 255.0f) < rt_a;\n"
"	#else\n"
"		bool bad = (127.5f / 255.0f) < rt_a;\n"
"	#endif\n"
"#elif (PS_DATE & 3) == 2\n"
"	// DATM == 1: Pixel with alpha equal to 0 will failed\n"
"	#if PS_RTA_CORRECTION\n"
"		bool bad = rt_a < (254.5f / 255.0f);\n"
"	#else\n"
"		bool bad = rt_a < (127.5f / 255.0f);\n"
"	#endif\n"
"#endif\n"
"\n"
"	if (bad) {\n"
"		discard;\n"
"	}\n"
"\n"
"#endif		// PS_DATE >= 5\n"
"\n"
"#if PS_DATE == 3\n"
"	int stencil_ceil = int(texelFetch(PrimMinTexture, ivec2(gl_FragCoord.xy), 0).r);\n"
"	// Note gl_PrimitiveID == stencil_ceil will be the primitive that will update\n"
"	// the bad alpha value so we must keep it.\n"
"\n"
"	if (gl_PrimitiveID > stencil_ceil) {\n"
"		discard;\n"
"	}\n"
"#endif\n"
"\n"
"	vec4 C = ps_color();\n"
"	bool atst_pass = atst(C);\n"
"\n"
"#if PS_AFAIL == 0 // KEEP or ATST off\n"
"	if (!atst_pass)\n"
"		discard;\n"
"#endif\n"
"\n"
"	// Must be done before alpha correction\n"
"\n"
"	// AA (Fixed one) will output a coverage of 1.0 as alpha\n"
"#if PS_FIXED_ONE_A\n"
"	C.a = 128.0f;\n"
"#endif\n"
"\n"
"#if SW_AD_TO_HW\n"
"	#if PS_RTA_CORRECTION\n"
"		vec4 RT = trunc(sample_from_rt() * 128.0f + 0.1f);\n"
"	#else\n"
"		vec4 RT = trunc(sample_from_rt() * 255.0f + 0.1f);\n"
"	#endif\n"
"\n"
"	vec4 alpha_blend = vec4(RT.a / 128.0f);\n"
"#else\n"
"	vec4 alpha_blend = vec4(C.a / 128.0f);\n"
"#endif\n"
"\n"
"	// Correct the ALPHA value based on the output format\n"
"#if (PS_DST_FMT == FMT_16)\n"
"	float A_one = 128.0f; // alpha output will be 0x80\n"
"	C.a = (PS_FBA != 0) ? A_one : step(128.0f, C.a) * A_one;\n"
"#elif (PS_DST_FMT == FMT_32) && (PS_FBA != 0)\n"
"	if(C.a < 128.0f) C.a += 128.0f;\n"
"#endif\n"
"\n"
"	// Get first primitive that will write a failling alpha value\n"
"#if PS_DATE == 1\n"
"\n"
"	// DATM == 0\n"
"	// Pixel with alpha equal to 1 will failed (128-255)\n"
"	o_col0 = (C.a > 127.5f) ? vec4(gl_PrimitiveID) : vec4(0x7FFFFFFF);\n"
"\n"
"#elif PS_DATE == 2\n"
"\n"
"	// DATM == 1\n"
"	// Pixel with alpha equal to 0 will failed (0-127)\n"
"	o_col0 = (C.a < 127.5f) ? vec4(gl_PrimitiveID) : vec4(0x7FFFFFFF);\n"
"\n"
"#else\n"
"	ps_blend(C, alpha_blend);\n"
"\n"
"#if PS_SHUFFLE\n"
"		#if !PS_READ16_SRC && !PS_SHUFFLE_SAME\n"
"			uvec4 denorm_c_after = uvec4(C);\n"
"			#if (PS_PROCESS_BA & SHUFFLE_READ)\n"
"				C.b = float(((denorm_c_after.r >> 3) & 0x1F) | ((denorm_c_after.g << 2) & 0xE0));\n"
"				C.a = float(((denorm_c_after.g >> 6) & 0x3) | ((denorm_c_after.b >> 1) & 0x7C) | (denorm_c_after.a & 0x80));\n"
"			#else\n"
"				C.r = float(((denorm_c_after.r >> 3) & 0x1F) | ((denorm_c_after.g << 2) & 0xE0));\n"
"				C.g = float(((denorm_c_after.g >> 6) & 0x3) | ((denorm_c_after.b >> 1) & 0x7C) | (denorm_c_after.a & 0x80));\n"
"			#endif\n"
"		#endif\n"
"\n"
"		// Special case for 32bit input and 16bit output, shuffle used by The Godfather\n"
"		#if PS_SHUFFLE_SAME\n"
"			#if (PS_PROCESS_BA & SHUFFLE_READ)\n"
"				uvec4 denorm_c = uvec4(C);\n"
"				C = vec4(float((denorm_c.b & 0x7Fu) | (denorm_c.a & 0x80u)));\n"
"			#else\n"
"				C.ga = C.rg;\n"
"			#endif\n"
"		// Copy of a 16bit source in to this target\n"
"		#elif PS_READ16_SRC\n"
"			uvec4 denorm_c = uvec4(C);\n"
"			uvec2 denorm_TA = uvec2(vec2(TA.xy) * 255.0f + 0.5f);\n"
"			C.rb = vec2(float((denorm_c.r >> 3) | (((denorm_c.g >> 3) & 0x7u) << 5)));\n"
"			C.ga = vec2(float((denorm_c.g >> 6) | ((denorm_c.b >> 3) << 2) | (denorm_TA.x & 0x80u)));\n"
"		// Write RB part. Mask will take care of the correct destination\n"
"		#elif PS_SHUFFLE_ACROSS\n"
"			#if(PS_PROCESS_BA == SHUFFLE_READWRITE && PS_PROCESS_RG == SHUFFLE_READWRITE)\n"
"				C.rb = C.br;\n"
"				float g_temp = C.g;\n"
"\n"
"				C.g = C.a;\n"
"				C.a = g_temp;	\n"
"			#elif(PS_PROCESS_BA & SHUFFLE_READ)\n"
"				C.rb = C.bb;\n"
"				C.ga = C.aa;\n"
"			#else\n"
"				C.rb = C.rr;\n"
"				C.ga = C.gg;\n"
"			#endif // PS_PROCESS_BA\n"
"		#endif // PS_SHUFFLE_ACROSS\n"
"	#endif // PS_SHUFFLE\n"
"\n"
"	ps_dither(C.rgb, alpha_blend.a);\n"
"\n"
"	// Color clamp/wrap needs to be done after sw blending and dithering\n"
"	ps_color_clamp_wrap(C.rgb);\n"
"\n"
"	ps_fbmask(C);\n"
"\n"
"	#if PS_AFAIL == 3 // RGB_ONLY\n"
"		// Use alpha blend factor to determine whether to update A.\n"
"		alpha_blend.a = float(atst_pass);\n"
"	#endif\n"
"\n"
"	#if !PS_NO_COLOR\n"
"		#if PS_RTA_CORRECTION\n"
"			o_col0.a = C.a / 128.0f;\n"
"		#else\n"
"			o_col0.a = C.a / 255.0f;\n"
"		#endif\n"
"		#if PS_HDR == 1\n"
"			o_col0.rgb = vec3(C.rgb / 65535.0f);\n"
"		#else\n"
"			o_col0.rgb = C.rgb / 255.0f;\n"
"		#endif\n"
"		#if !PS_NO_COLOR1\n"
"			o_col1 = alpha_blend;\n"
"		#endif\n"
"	#endif\n"
"\n"
"	#if PS_ZCLAMP\n"
"		gl_FragDepth = min(gl_FragCoord.z, MaxDepthPS);\n"
"	#endif\n"
"\n"
"#endif // PS_DATE\n"
"}\n"
"\n"
"#endif\n"
;
