static const char convert_glsl_shader_raw[] = 
"#ifdef VERTEX_SHADER\n"
"\n"
"layout(location = 0) in vec4 a_pos;\n"
"layout(location = 1) in vec2 a_tex;\n"
"\n"
"layout(location = 0) out vec2 v_tex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(a_pos.x, -a_pos.y, a_pos.z, a_pos.w);\n"
"	v_tex = a_tex;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"layout(location = 0) in vec2 v_tex;\n"
"\n"
"#if defined(ps_convert_rgba8_16bits) || defined(ps_convert_float32_32bits)\n"
"layout(location = 0) out uint o_col0;\n"
"#elif !defined(ps_datm1) && !defined(ps_datm0) && !defined(ps_datm1_rta_correction) && !defined(ps_datm0_rta_correction) && !defined(ps_convert_rgba8_float32) && !defined(ps_convert_rgba8_float24) && !defined(ps_convert_rgba8_float16) && !defined(ps_convert_rgb5a1_float16) && !defined(ps_convert_rgba8_float32_biln) && !defined(ps_convert_rgba8_float24_biln) && !defined(ps_convert_rgba8_float16_biln) && !defined(ps_convert_rgb5a1_float16_biln) && !defined(ps_depth_copy)\n"
"layout(location = 0) out vec4 o_col0;\n"
"#endif\n"
"\n"
"layout(set = 0, binding = 0) uniform sampler2D samp0;\n"
"\n"
"vec4 sample_c(vec2 uv)\n"
"{\n"
"	return texture(samp0, uv);\n"
"}\n"
"\n"
"#ifdef ps_copy\n"
"void ps_copy()\n"
"{\n"
"	o_col0 = sample_c(v_tex);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_depth_copy\n"
"void ps_depth_copy()\n"
"{\n"
"  gl_FragDepth = sample_c(v_tex).r;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_downsample_copy\n"
"layout(push_constant) uniform cb10\n"
"{\n"
"	ivec2 ClampMin;\n"
"	int DownsampleFactor;\n"
"	int pad0;\n"
"	float Weight;\n"
"	vec3 pad1;\n"
"};\n"
"void ps_downsample_copy()\n"
"{\n"
"	ivec2 coord = max(ivec2(gl_FragCoord.xy) * DownsampleFactor, ClampMin);\n"
"	vec4 result = vec4(0);\n"
"	for (int yoff = 0; yoff < DownsampleFactor; yoff++)\n"
"	{\n"
"		for (int xoff = 0; xoff < DownsampleFactor; xoff++)\n"
"			result += texelFetch(samp0, coord + ivec2(xoff, yoff), 0);\n"
"	}\n"
"	o_col0 = result / Weight;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_filter_transparency\n"
"void ps_filter_transparency()\n"
"{\n"
"	vec4 c = sample_c(v_tex);\n"
"	o_col0 = vec4(c.rgb, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_16bits\n"
"// Need to be careful with precision here, it can break games like Spider-Man 3 and Dogs Life\n"
"void ps_convert_rgba8_16bits()\n"
"{\n"
"	uvec4 i = uvec4(sample_c(v_tex) * vec4(255.5f, 255.5f, 255.5f, 255.5f));\n"
"\n"
"	o_col0 = ((i.x & 0x00F8u) >> 3) | ((i.y & 0x00F8u) << 2) | ((i.z & 0x00f8u) << 7) | ((i.w & 0x80u) << 8);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_datm1\n"
"void ps_datm1()\n"
"{\n"
"	if(sample_c(v_tex).a < (127.5f / 255.0f)) // >= 0x80 pass\n"
"		discard;\n"
"\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_datm0\n"
"void ps_datm0()\n"
"{\n"
"	if((127.5f / 255.0f) < sample_c(v_tex).a) // < 0x80 pass (== 0x80 should not pass)\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_datm1_rta_correction\n"
"void ps_datm1_rta_correction()\n"
"{\n"
"	if(sample_c(v_tex).a < (254.5f / 255.0f)) // >= 0x80 pass\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_datm0_rta_correction\n"
"void ps_datm0_rta_correction()\n"
"{\n"
"	if((254.5f / 255.0f) < sample_c(v_tex).a) // < 0x80 pass (== 0x80 should not pass)\n"
"		discard;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_rta_correction\n"
"void ps_rta_correction()\n"
"{\n"
"	vec4 value = sample_c(v_tex);\n"
"	o_col0 = vec4(value.rgb, value.a / (128.25f / 255.0f));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_rta_decorrection\n"
"void ps_rta_decorrection()\n"
"{\n"
"	vec4 value = sample_c(v_tex);\n"
"	o_col0 = vec4(value.rgb, value.a * (128.25f / 255.0f));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_hdr_init\n"
"void ps_hdr_init()\n"
"{\n"
"	vec4 value = sample_c(v_tex);\n"
"	o_col0 = vec4(roundEven(value.rgb * 255.0f) / 65535.0f, value.a);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_hdr_resolve\n"
"void ps_hdr_resolve()\n"
"{\n"
"	vec4 value = sample_c(v_tex);\n"
"	o_col0 = vec4(vec3(uvec3(value.rgb * 65535.5f) & 255u) / 255.0f, value.a);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float32_32bits\n"
"void ps_convert_float32_32bits()\n"
"{\n"
"	// Convert a vec32 depth texture into a 32 bits UINT texture\n"
"	o_col0 = uint(exp2(32.0f) * sample_c(v_tex).r);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float32_rgba8\n"
"void ps_convert_float32_rgba8()\n"
"{\n"
"	// Convert a vec32 depth texture into a RGBA color texture\n"
"	uint d = uint(sample_c(v_tex).r * exp2(32.0f));\n"
"	o_col0 = vec4(uvec4((d & 0xFFu), ((d >> 8) & 0xFFu), ((d >> 16) & 0xFFu), (d >> 24))) / vec4(255.0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_float16_rgb5a1\n"
"void ps_convert_float16_rgb5a1()\n"
"{\n"
"	// Convert a vec32 (only 16 lsb) depth into a RGB5A1 color texture\n"
"	uint d = uint(sample_c(v_tex).r * exp2(32.0f));\n"
"	o_col0 = vec4(uvec4(d << 3, d >> 2, d >> 7, d >> 8) & uvec4(0xf8, 0xf8, 0xf8, 0x80)) / 255.0f;\n"
"}\n"
"#endif\n"
"\n"
"float rgba8_to_depth32(vec4 unorm)\n"
"{\n"
"	uvec4 c = uvec4(unorm * vec4(255.5f));\n"
"	return float(c.r | (c.g << 8) | (c.b << 16) | (c.a << 24)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgba8_to_depth24(vec4 unorm)\n"
"{\n"
"	uvec3 c = uvec3(unorm.rgb * vec3(255.5f));\n"
"	return float(c.r | (c.g << 8) | (c.b << 16)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgba8_to_depth16(vec4 unorm)\n"
"{\n"
"	uvec2 c = uvec2(unorm.rg * vec2(255.5f));\n"
"	return float(c.r | (c.g << 8)) * exp2(-32.0f);\n"
"}\n"
"\n"
"float rgb5a1_to_depth16(vec4 unorm)\n"
"{\n"
"	uvec4 c = uvec4(unorm * vec4(255.5f));\n"
"	return float(((c.r & 0xF8u) >> 3) | ((c.g & 0xF8u) << 2) | ((c.b & 0xF8u) << 7) | ((c.a & 0x80u) << 8)) * exp2(-32.0f);\n"
"}\n"
"\n"
"#ifdef ps_convert_float32_float24\n"
"void ps_convert_float32_float24()\n"
"{\n"
"	// Truncates depth value to 24bits\n"
"	uint d = uint(sample_c(v_tex).r * exp2(32.0f)) & 0xFFFFFFu;\n"
"	gl_FragDepth = float(d) * exp2(-32.0f);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float32\n"
"void ps_convert_rgba8_float32()\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth32(sample_c(v_tex));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float24\n"
"void ps_convert_rgba8_float24()\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth24(sample_c(v_tex));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float16\n"
"void ps_convert_rgba8_float16()\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	gl_FragDepth = rgba8_to_depth16(sample_c(v_tex));\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgb5a1_float16\n"
"void ps_convert_rgb5a1_float16()\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	gl_FragDepth = rgb5a1_to_depth16(sample_c(v_tex));\n"
"}\n"
"#endif\n"
"\n"
"#define SAMPLE_RGBA_DEPTH_BILN(CONVERT_FN) ivec2 dims = textureSize(samp0, 0); vec2 top_left_f = v_tex * vec2(dims) - 0.5f; ivec2 top_left = ivec2(floor(top_left_f)); ivec4 coords = clamp(ivec4(top_left, top_left + 1), ivec4(0), dims.xyxy - 1); vec2 mix_vals = fract(top_left_f); float depthTL = CONVERT_FN(texelFetch(samp0, coords.xy, 0)); float depthTR = CONVERT_FN(texelFetch(samp0, coords.zy, 0)); float depthBL = CONVERT_FN(texelFetch(samp0, coords.xw, 0)); float depthBR = CONVERT_FN(texelFetch(samp0, coords.zw, 0)); gl_FragDepth = mix(mix(depthTL, depthTR, mix_vals.x), mix(depthBL, depthBR, mix_vals.x), mix_vals.y);\n"
"\n"
"#ifdef ps_convert_rgba8_float32_biln\n"
"void ps_convert_rgba8_float32_biln()\n"
"{\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth32);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float24_biln\n"
"void ps_convert_rgba8_float24_biln()\n"
"{\n"
"	// Same as above but without the alpha channel (24 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth24);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba8_float16_biln\n"
"void ps_convert_rgba8_float16_biln()\n"
"{\n"
"	// Same as above but without the A/B channels (16 bits Z)\n"
"\n"
"	// Convert an RGBA texture into a float depth texture\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgba8_to_depth16);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgb5a1_float16_biln\n"
"void ps_convert_rgb5a1_float16_biln()\n"
"{\n"
"	// Convert an RGB5A1 (saved as RGBA8) color to a 16 bit Z\n"
"	SAMPLE_RGBA_DEPTH_BILN(rgb5a1_to_depth16);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_rgba_8i\n"
"layout(push_constant) uniform cb10\n"
"{\n"
"	uint SBW;\n"
"	uint DBW;\n"
"	uvec2 cb_pad1;\n"
"	float ScaleFactor;\n"
"	vec3 cb_pad2;\n"
"};\n"
"\n"
"void ps_convert_rgba_8i()\n"
"{\n"
"	// Convert a RGBA texture into a 8 bits packed texture\n"
"	// Input column: 8x2 RGBA pixels\n"
"	// 0: 8 RGBA\n"
"	// 1: 8 RGBA\n"
"	// Output column: 16x4 Index pixels\n"
"	// 0: 8 R | 8 B\n"
"	// 1: 8 R | 8 B\n"
"	// 2: 8 G | 8 A\n"
"	// 3: 8 G | 8 A\n"
"	uvec2 pos = uvec2(gl_FragCoord.xy);\n"
"\n"
"	// Collapse separate R G B A areas into their base pixel\n"
"	uvec2 block = (pos & ~uvec2(15u, 3u)) >> 1;\n"
"	uvec2 subblock = pos & uvec2(7u, 1u);\n"
"	uvec2 coord = block | subblock;\n"
"\n"
"	// Compensate for potentially differing page pitch.\n"
"	uvec2 block_xy = coord / uvec2(64u, 32u);\n"
"	uint block_num = (block_xy.y * (DBW / 128u)) + block_xy.x;\n"
"	uvec2 block_offset = uvec2((block_num % (SBW / 64u)) * 64u, (block_num / (SBW / 64u)) * 32u);\n"
"	coord = (coord % uvec2(64u, 32u)) + block_offset;\n"
"\n"
"	// Apply offset to cols 1 and 2\n"
"	uint is_col23 = pos.y & 4u;\n"
"	uint is_col13 = pos.y & 2u;\n"
"	uint is_col12 = is_col23 ^ (is_col13 << 1);\n"
"	coord.x ^= is_col12; // If cols 1 or 2, flip bit 3 of x\n"
"\n"
"	if (floor(ScaleFactor) != ScaleFactor)\n"
"		coord = uvec2(vec2(coord) * ScaleFactor);\n"
"	else\n"
"		coord *= uvec2(ScaleFactor);\n"
"\n"
"	vec4 pixel = texelFetch(samp0, ivec2(coord), 0);\n"
"	vec2  sel0 = (pos.y & 2u) == 0u ? pixel.rb : pixel.ga;\n"
"	float sel1 = (pos.x & 8u) == 0u ? sel0.x : sel0.y;\n"
"	o_col0 = vec4(sel1); // Divide by something here?\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_clut_4\n"
"layout(push_constant) uniform cb10\n"
"{\n"
"	uvec2 offset;\n"
"	uint doffset;\n"
"	uint cb_pad1;\n"
"	float scale;\n"
"	vec3 cb_pad2;\n"
"};\n"
"\n"
"void ps_convert_clut_4()\n"
"{\n"
"	// CLUT4 is easy, just two rows of 8x8.\n"
"	uint index = uint(gl_FragCoord.x) + doffset;\n"
"	uvec2 pos = uvec2(index % 8u, index / 8u);\n"
"\n"
"	ivec2 final = ivec2(floor(vec2(offset + pos) * vec2(scale)));\n"
"	o_col0 = texelFetch(samp0, final, 0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_convert_clut_8\n"
"layout(push_constant) uniform cb10\n"
"{\n"
"	uvec2 offset;\n"
"	uint doffset;\n"
"	uint cb_pad1;\n"
"	float scale;\n"
"	vec3 cb_pad2;\n"
"};\n"
"\n"
"void ps_convert_clut_8()\n"
"{\n"
"	uint index = min(uint(gl_FragCoord.x) + doffset, 255u);\n"
"\n"
"	// CLUT is arranged into 8 groups of 16x2, with the top-right and bottom-left quadrants swapped.\n"
"	// This can probably be done better..\n"
"	uint subgroup = (index / 8u) % 4u;\n"
"	uvec2 pos;\n"
"	pos.x = (index % 8u) + ((subgroup >= 2u) ? 8u : 0u);\n"
"	pos.y = ((index / 32u) * 2u) + (subgroup % 2u);\n"
"\n"
"	ivec2 final = ivec2(floor(vec2(offset + pos) * vec2(scale)));\n"
"	o_col0 = texelFetch(samp0, final, 0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef ps_yuv\n"
"layout(push_constant) uniform cb10\n"
"{\n"
"	int EMODA;\n"
"	int EMODC;\n"
"};\n"
"\n"
"void ps_yuv()\n"
"{\n"
"	vec4 i = sample_c(v_tex);\n"
"	vec4 o = vec4(0.0f);\n"
"\n"
"	mat3 rgb2yuv;\n"
"	rgb2yuv[0] = vec3(0.587, -0.311, -0.419);\n"
"	rgb2yuv[1] = vec3(0.114, 0.500, -0.081);\n"
"	rgb2yuv[2] = vec3(0.299, -0.169, 0.500);\n"
"\n"
"	vec3 yuv = rgb2yuv * i.gbr;\n"
"\n"
"	float Y = float(0xDB)/255.0f * yuv.x + float(0x10)/255.0f;\n"
"	float Cr = float(0xE0)/255.0f * yuv.y + float(0x80)/255.0f;\n"
"	float Cb = float(0xE0)/255.0f * yuv.z + float(0x80)/255.0f;\n"
"\n"
"	switch(EMODA)\n"
"	{\n"
"		case 0:\n"
"			o.a = i.a;\n"
"			break;\n"
"		case 1:\n"
"			o.a = Y;\n"
"			break;\n"
"		case 2:\n"
"			o.a = Y/2.0f;\n"
"			break;\n"
"		case 3:\n"
"			o.a = 0.0f;\n"
"			break;\n"
"	}\n"
"\n"
"	switch(EMODC)\n"
"	{\n"
"		case 0:\n"
"			o.rgb = i.rgb;\n"
"			break;\n"
"		case 1:\n"
"			o.rgb = vec3(Y);\n"
"			break;\n"
"		case 2:\n"
"			o.rgb = vec3(Y, Cb, Cr);\n"
"			break;\n"
"		case 3:\n"
"			o.rgb = vec3(i.a);\n"
"			break;\n"
"	}\n"
"\n"
"	o_col0 = o;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(ps_stencil_image_init_0) || defined(ps_stencil_image_init_1) || defined(ps_stencil_image_init_2) || defined(ps_stencil_image_init_3)\n"
"\n"
"void main()\n"
"{\n"
"	o_col0 = vec4(0x7FFFFFFF);\n"
"\n"
"	#ifdef ps_stencil_image_init_0\n"
"		if((127.5f / 255.0f) < sample_c(v_tex).a) // < 0x80 pass (== 0x80 should not pass)\n"
"			o_col0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_1\n"
"		if(sample_c(v_tex).a < (127.5f / 255.0f)) // >= 0x80 pass\n"
"			o_col0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_2\n"
"		if((254.5f / 255.0f) < sample_c(v_tex).a) // < 0x80 pass (== 0x80 should not pass)\n"
"			o_col0 = vec4(-1);\n"
"	#endif\n"
"	#ifdef ps_stencil_image_init_3\n"
"		if(sample_c(v_tex).a < (254.5f / 255.0f)) // >= 0x80 pass\n"
"			o_col0 = vec4(-1);\n"
"	#endif\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
;
